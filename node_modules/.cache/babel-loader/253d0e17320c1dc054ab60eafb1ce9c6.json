{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _helpers = require('../utils/helpers');\n\nvar _exenv = require('exenv');\n\nvar _unionClassNames = require('../utils/union-class-names');\n\nvar _unionClassNames2 = _interopRequireDefault(_unionClassNames);\n\nvar _injectStyle = require('../utils/inject-style');\n\nvar _select = require('../style/select');\n\nvar _select2 = _interopRequireDefault(_select);\n\nvar _select3 = require('../config/select');\n\nvar _select4 = _interopRequireDefault(_select3);\n\nvar _isComponentOfType = require('../utils/is-component-of-type');\n\nvar _isComponentOfType2 = _interopRequireDefault(_isComponentOfType);\n\nvar _Option = require('../components/Option');\n\nvar _Option2 = _interopRequireDefault(_Option);\n\nvar _Placeholder = require('../components/Placeholder');\n\nvar _Placeholder2 = _interopRequireDefault(_Placeholder);\n\nvar _Separator = require('../components/Separator');\n\nvar _Separator2 = _interopRequireDefault(_Separator);\n\nvar _SelectItem = require('../components/SelectItem');\n\nvar _SelectItem2 = _interopRequireDefault(_SelectItem);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * Returns true if the provided property is a Placeholder component from Belle.\n */\n\n\nfunction isPlaceholder(reactElement) {\n  return (0, _isComponentOfType2.default)(_Placeholder2.default, reactElement);\n}\n/**\n * Returns true if the provided property is a Option component from Belle.\n */\n\n\nfunction isOption(reactElement) {\n  return (0, _isComponentOfType2.default)(_Option2.default, reactElement);\n}\n/**\n * Returns true if the provided property is a Separator component from Belle.\n */\n\n\nfunction isSeparator(reactElement) {\n  return (0, _isComponentOfType2.default)(_Separator2.default, reactElement);\n}\n/**\n * Verifies that the children is an array containing only Options & at maximum\n * one Placeholder.\n */\n\n\nfunction validateChildrenAreOptionsAndMaximumOnePlaceholder(props, propName, componentName) {\n  var validChildren = (0, _helpers.filterReactChildren)(props[propName], function (node) {\n    return isOption(node) || isSeparator(node) || isPlaceholder(node);\n  });\n\n  if (_react2.default.Children.count(props[propName]) !== _react2.default.Children.count(validChildren)) {\n    return new Error('Invalid children supplied to `' + componentName + '`, expected an Option, Separator or Placeholder component from Belle.');\n  }\n\n  var placeholders = (0, _helpers.filterReactChildren)(props[propName], function (node) {\n    return isPlaceholder(node);\n  });\n\n  if (_react2.default.Children.count(placeholders) > 1) {\n    return new Error('Invalid children supplied to `' + componentName + '`, expected only one Placeholder component.');\n  }\n\n  return undefined;\n}\n\nvar selectPropTypes = {\n  children: validateChildrenAreOptionsAndMaximumOnePlaceholder,\n  value: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.instanceOf(Date)]),\n  defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string, _propTypes2.default.number]),\n  onUpdate: _propTypes2.default.func,\n  valueLink: _propTypes2.default.shape({\n    value: _propTypes2.default.string.isRequired,\n    requestChange: _propTypes2.default.func.isRequired\n  }),\n  className: _propTypes2.default.string,\n  shouldPositionOptions: _propTypes2.default.bool,\n  positionOptions: _propTypes2.default.func,\n  style: _propTypes2.default.object,\n  focusStyle: _propTypes2.default.object,\n  hoverStyle: _propTypes2.default.object,\n  activeStyle: _propTypes2.default.object,\n  wrapperStyle: _propTypes2.default.object,\n  menuStyle: _propTypes2.default.object,\n  caretToOpenStyle: _propTypes2.default.object,\n  caretToCloseStyle: _propTypes2.default.object,\n  wrapperProps: _propTypes2.default.object,\n  menuProps: _propTypes2.default.object,\n  caretProps: _propTypes2.default.object,\n  disabled: _propTypes2.default.bool,\n  disabledStyle: _propTypes2.default.object,\n  disabledHoverStyle: _propTypes2.default.object,\n  disabledCaretToOpenStyle: _propTypes2.default.object,\n  id: _propTypes2.default.string,\n  onClick: _propTypes2.default.func,\n  onTouchCancel: _propTypes2.default.func,\n  onMouseDown: _propTypes2.default.func,\n  onMouseUp: _propTypes2.default.func,\n  onTouchEnd: _propTypes2.default.func,\n  onTouchStart: _propTypes2.default.func\n};\n/**\n * Update hover style for the speficied styleId.\n *\n * @param styleId {string} - a unique id that exists as class attribute in the DOM\n * @param properties {object} - the components properties optionally containing hoverStyle\n */\n\nfunction updatePseudoClassStyle(styleId, properties) {\n  var hoverStyle = _extends({}, _select2.default.hoverStyle, properties.hoverStyle);\n\n  var disabledHoverStyle = _extends({}, _select2.default.disabledHoverStyle, properties.disabledHoverStyle);\n\n  var styles = [{\n    id: styleId,\n    style: hoverStyle,\n    pseudoClass: 'hover'\n  }, {\n    id: styleId,\n    style: disabledHoverStyle,\n    pseudoClass: 'hover',\n    disabled: true\n  }];\n  (0, _injectStyle.injectStyles)(styles);\n}\n/**\n * Returns true in case there one more element in the list.\n */\n\n\nvar hasNext = function hasNext(list, currentIndex) {\n  return currentIndex + 2 <= list.length;\n};\n/**\n * Returns true in case there is one previous element in the list.\n */\n\n\nvar hasPrevious = function hasPrevious(list, currentIndex) {\n  return currentIndex - 1 >= 0;\n};\n/**\n * Returns an object with properties that are relevant for the wrapping div of\n * the selected option.\n */\n\n\nfunction sanitizeSelectedOptionWrapperProps(properties) {\n  return (0, _helpers.omit)(properties, Object.keys(selectPropTypes));\n}\n/**\n * Returns an object with properties that are relevant for the wrapping div of\n * the selected option.\n */\n\n\nfunction sanitizeWrapperProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'ref', 'tabIndex', 'onKeyDown', 'onBlur', 'onFocus']);\n}\n/**\n * Returns an object with properties that are relevant for the wrapping div of\n * the selected option.\n */\n\n\nfunction sanitizeMenuProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'ref', 'aria-labelledby', 'role']);\n}\n/**\n * Returns an object with properties that are relevant for the wrapping div of\n * the selected option.\n */\n\n\nfunction sanitizeCaretProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'ref']);\n}\n/**\n * Select component.\n *\n * In its simplest form the select component behaves almost identical to the\n * native HTML select which the exception that it comes with beautiful styles.\n *\n * Example:\n *\n *     <Select defaultValue=\"rome\">\n *       <Option value=\"vienna\">Vienna</Option>\n *       <Option value=\"rome\">Rome</Option>\n *     </Select>\n *\n * For more advanced examples please see:\n * nikgraf.github.io/belle/#/component/select\n *\n * This component was inpired by:\n * - Jet Watson: https://github.com/JedWatson/react-select\n * - Instructure React Team: https://github.com/instructure-react/react-select-box\n */\n\n\nvar Select = function (_Component) {\n  _inherits(Select, _Component);\n  /*\n   * Initialize the component based on the provided properties.\n   *\n   * By default the Select is closed & the focused option in case the user opens\n   * it will be the selected option.\n   */\n\n\n  function Select(properties) {\n    _classCallCheck(this, Select);\n\n    var _this = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, properties));\n\n    _this._onTouchStartAtOption = function (event, index) {\n      if (event.touches.length === 1) {\n        _this._touchStartedAt = _this._getValueForIndex(index); // save the scroll position\n\n        var menuNode = _reactDom2.default.findDOMNode(_this.refs.menu);\n\n        if (menuNode.scrollHeight > menuNode.offsetHeight) {\n          _this._scrollTopPosition = menuNode.scrollTop; // Note: don't use setState in here as it would prevent the scrolling\n        } else {\n          _this._scrollTopPosition = 0;\n\n          _this.setState({\n            focusedOptionValue: _this._touchStartedAt\n          });\n        } // reset interaction\n\n\n        _this._scrollActive = false;\n      }\n    };\n\n    _this._onTouchMoveAtOption = function () {\n      var menuNode = _reactDom2.default.findDOMNode(_this.refs.menu);\n\n      if (menuNode.scrollTop !== _this._scrollTopPosition) {\n        _this._scrollActive = true;\n      }\n    };\n\n    _this._onTouchEndAtOption = function (event, index) {\n      if (_this._touchStartedAt && !_this._scrollActive) {\n        var value = _this._getValueForIndex(index);\n\n        if (_this._touchStartedAt === value) {\n          event.preventDefault();\n\n          _this._triggerChange(value);\n        }\n      }\n\n      _this._touchStartedAt = undefined;\n    };\n\n    _this._onTouchCancelAtOption = function () {\n      _this._touchStartedAt = undefined;\n    };\n\n    _this._onClickAtOption = function (index) {\n      _this._triggerChange(_this._getValueForIndex(index));\n    };\n\n    _this._onBlur = function (event) {\n      _this.setState({\n        isOpen: false,\n        isFocused: false\n      });\n\n      if (_this.props.wrapperProps && _this.props.wrapperProps.onBlur) {\n        _this.props.wrapperProps.onBlur(event);\n      }\n    };\n\n    _this._onFocus = function (event) {\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.wrapperProps && _this.props.wrapperProps.onFocus) {\n        _this.props.wrapperProps.onFocus(event);\n      }\n    };\n\n    _this._onMouseEnterAtOption = function (index) {\n      _this.setState({\n        focusedOptionValue: _this._getValueForIndex(index)\n      });\n    };\n\n    _this._onTouchStartToggleMenu = function (event) {\n      if (event.touches.length === 1) {\n        _this.setState({\n          isTouchedToToggle: true,\n          isActive: true\n        });\n      } else {\n        _this.setState({\n          isTouchedToToggle: false\n        });\n      }\n\n      if (_this.props.onTouchStart) {\n        _this.props.onTouchStart(event);\n      }\n    };\n\n    _this._onTouchEndToggleMenu = function (event) {\n      // In case touch events are used preventDefault is applied to avoid\n      // triggering the click event which would cause trouble for toggling.\n      // In any case calling setState triggers a render. This leads to the fact\n      // that the click event won't be triggered anyways. Nik assumes it's due the\n      // element won't be in the DOM anymore.\n      // This also means the Select's onClick won't be triggered for touchDevices.\n      event.preventDefault();\n      /* To avoid weird behaviour we check before focusing again - no specific use-case found */\n\n      var wrapperNode = _reactDom2.default.findDOMNode(_this.refs.wrapper);\n\n      if (document.activeElement !== wrapperNode) {\n        wrapperNode.focus();\n      }\n\n      if (_this.state.isTouchedToToggle) {\n        if (_this.state.isOpen) {\n          _this.setState({\n            isOpen: false\n          });\n        } else {\n          _this.setState({\n            isOpen: true\n          });\n        }\n      }\n\n      _this.setState({\n        isTouchedToToggle: false,\n        isActive: false\n      });\n\n      if (_this.props.onTouchEnd) {\n        _this.props.onTouchEnd(event);\n      }\n    };\n\n    _this._onTouchCancelToggleMenu = function (event) {\n      _this.setState({\n        isTouchedToToggle: false,\n        isActive: false\n      });\n\n      if (_this.props.onTouchCancel) {\n        _this.props.onTouchCancel(event);\n      }\n    };\n\n    _this._onMouseDown = function (event) {\n      _this.setState({\n        isActive: true\n      });\n\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(event);\n      }\n    };\n\n    _this._onMouseUp = function (event) {\n      _this.setState({\n        isActive: false\n      });\n\n      if (_this.props.onMouseUp) {\n        _this.props.onMouseUp(event);\n      }\n    };\n\n    _this._onMouseUpOnDocument = function () {\n      _this.setState({\n        isActive: false\n      });\n    };\n\n    _this._onContextMenu = function () {\n      _this.setState({\n        isActive: false\n      });\n    };\n\n    _this._onArrowDownKeyDown = function () {\n      if (_this.state.focusedOptionValue !== void 0) {\n        var indexOfFocusedOption = _this._getIndexOfFocusedOption();\n\n        if (hasNext(_this.options, indexOfFocusedOption)) {\n          _this.setState({\n            focusedOptionValue: _this.options[indexOfFocusedOption + 1].props.value\n          });\n        }\n      } else {\n        _this.setState({\n          focusedOptionValue: (0, _helpers.first)(_this.options).props.value\n        });\n      }\n    };\n\n    _this._onArrowUpKeyDown = function () {\n      if (_this.state.focusedOptionValue !== void 0) {\n        var indexOfFocusedOption = _this._getIndexOfFocusedOption();\n\n        if (hasPrevious(_this.options, indexOfFocusedOption)) {\n          _this.setState({\n            focusedOptionValue: _this.options[indexOfFocusedOption - 1].props.value\n          });\n        }\n      } else {\n        _this.setState({\n          focusedOptionValue: (0, _helpers.last)(_this.options).props.value\n        });\n      }\n    };\n\n    _this._onEnterOrSpaceKeyDown = function () {\n      _this._triggerChange(_this.state.focusedOptionValue);\n    };\n\n    _this._onKeyDown = function (event) {\n      if (!_this.props.disabled) {\n        if (!(0, _helpers.isEmpty)(_this.options)) {\n          if (!_this.state.isOpen) {\n            if (event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === ' ') {\n              event.preventDefault();\n\n              _this.setState({\n                isOpen: true\n              });\n            }\n          } else {\n            // Updates the state to set focus on the next option\n            // In case no option is active it should jump to the first.\n            // In case it is the last it should stop there.\n            if (event.key === 'ArrowDown') {\n              event.preventDefault();\n\n              _this._onArrowDownKeyDown();\n            } else if (event.key === 'ArrowUp') {\n              event.preventDefault();\n\n              _this._onArrowUpKeyDown();\n            } else if (event.key === 'Enter' || event.key === ' ') {\n              event.preventDefault();\n\n              _this._onEnterOrSpaceKeyDown();\n            }\n          }\n\n          if (event.key === 'Escape') {\n            event.preventDefault();\n\n            _this.setState({\n              isOpen: false\n            });\n          }\n        }\n      }\n\n      if (_this.props.wrapperProps && _this.props.wrapperProps.onKeyDown) {\n        _this.props.wrapperProps.onKeyDown(event);\n      }\n    };\n\n    _this._onClickToggleMenu = function (event) {\n      if (!_this.props.disabled) {\n        if (_this.state.isOpen) {\n          _this.setState({\n            isOpen: false\n          });\n        } else {\n          _this.setState({\n            isOpen: true\n          });\n        }\n      }\n\n      if (_this.props.onClick) {\n        _this.props.onClick(event);\n      }\n    };\n\n    var selectedValue = void 0;\n    var focusedOptionValue = void 0;\n\n    if (properties.children) {\n      _this.children = (0, _helpers.flattenReactChildren)(properties.children);\n      _this.options = (0, _helpers.filter)(_this.children, isOption);\n    }\n\n    if ((0, _helpers.has)(properties, 'valueLink')) {\n      selectedValue = properties.valueLink.value;\n      focusedOptionValue = selectedValue;\n    } else if ((0, _helpers.has)(properties, 'value')) {\n      selectedValue = properties.value;\n      focusedOptionValue = selectedValue;\n    } else if ((0, _helpers.has)(properties, 'defaultValue')) {\n      selectedValue = properties.defaultValue;\n      focusedOptionValue = selectedValue;\n    } else if (!(0, _helpers.isEmpty)(_this.children) && !(0, _helpers.some)(_this.children, isPlaceholder)) {\n      var firstOption = (0, _helpers.first)(_this.options);\n      selectedValue = firstOption ? firstOption.props.value : void 0;\n      focusedOptionValue = selectedValue;\n    } else if (!(0, _helpers.isEmpty)(_this.children)) {\n      var _firstOption = (0, _helpers.first)(_this.options);\n\n      focusedOptionValue = _firstOption ? _firstOption.props.value : void 0;\n    }\n\n    _this.state = {\n      isOpen: false,\n      isFocused: false,\n      selectedValue: selectedValue,\n      focusedOptionValue: focusedOptionValue,\n      selectedOptionWrapperProps: sanitizeSelectedOptionWrapperProps(properties),\n      wrapperProps: sanitizeWrapperProps(properties.wrapperProps),\n      menuProps: sanitizeMenuProps(properties.menuProps),\n      caretProps: sanitizeCaretProps(properties.caretProps),\n      isTouchedToToggle: false\n    };\n    return _this;\n  }\n\n  _createClass(Select, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      return {\n        isDisabled: this.props.disabled,\n        isHoveredValue: this.state.focusedOptionValue\n      };\n    }\n    /**\n     * Generates the style-id & inject the focus & hover style.\n     */\n\n  }, {\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      var id = (0, _helpers.uniqueId)(); // Note: To ensure server side rendering creates the same results React's internal\n      // id for this element is leveraged.\n\n      this.selectedOptionWrapperId = this.props.id ? this.props.id : 'belle-select-id-' + id;\n      this._styleId = 'style-id' + id;\n      updatePseudoClassStyle(this._styleId, this.props);\n\n      if (_exenv.canUseDOM) {\n        this.mouseUpOnDocumentCallback = this._onMouseUpOnDocument;\n        document.addEventListener('mouseup', this.mouseUpOnDocumentCallback);\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(properties) {\n      if (properties.children) {\n        this.children = (0, _helpers.flattenReactChildren)(properties.children);\n        this.options = (0, _helpers.filter)(this.children, isOption);\n      }\n\n      var newState = {\n        selectedOptionWrapperProps: sanitizeSelectedOptionWrapperProps(properties),\n        wrapperProps: sanitizeWrapperProps(properties.wrapperProps),\n        menuProps: sanitizeMenuProps(properties.menuProps),\n        caretProps: sanitizeCaretProps(properties.caretProps)\n      };\n\n      if ((0, _helpers.has)(properties, 'valueLink')) {\n        newState.selectedValue = properties.valueLink.value;\n        newState.focusedOptionValue = properties.valueLink.value;\n      } else if ((0, _helpers.has)(properties, 'value')) {\n        newState.selectedValue = properties.value;\n        newState.focusedOptionValue = properties.value;\n      }\n\n      this.setState(newState);\n      (0, _injectStyle.removeStyle)(this._styleId);\n      updatePseudoClassStyle(this._styleId, properties);\n    }\n    /**\n     * In case shouldPositionOptions is active the scrollTop position is stored\n     * to be applied later on. The menu is hidden to make sure it is\n     * not displayed beofre repositioned.\n     */\n\n  }, {\n    key: 'componentWillUpdate',\n    value: function componentWillUpdate(nextProperties, nextState) {\n      var shouldPositionOptions = (0, _helpers.has)(nextProperties, 'shouldPositionOptions') ? nextProperties.shouldPositionOptions : _select4.default.shouldPositionOptions;\n\n      if (shouldPositionOptions) {\n        var menuNode = _reactDom2.default.findDOMNode(this.refs.menu);\n\n        this.cachedMenuScrollTop = menuNode.scrollTop;\n\n        if (!this.state.isOpen && nextState.isOpen) {\n          menuNode.style.display = 'none';\n        }\n      }\n    }\n    /**\n     * In case shouldPositionOptions is active when opening the menu it is\n     * repositioned & switched to be visible.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(previousProperties, previousState) {\n      var shouldPositionOptions = (0, _helpers.has)(this.props, 'shouldPositionOptions') ? this.props.shouldPositionOptions : _select4.default.shouldPositionOptions;\n\n      if (shouldPositionOptions && !this.props.disabled) {\n        var menuNode = _reactDom2.default.findDOMNode(this.refs.menu); // the menu was just opened\n\n\n        if (!previousState.isOpen && this.state.isOpen && this.children && this.children.length > 0) {\n          var positionOptions = (0, _helpers.has)(this.props, 'positionOptions') ? this.props.positionOptions : _select4.default.positionOptions;\n          positionOptions(this); // restore the old scrollTop position\n        } else {\n          menuNode.scrollTop = this.cachedMenuScrollTop;\n        }\n\n        var separators = (0, _helpers.filter)(this.children, isSeparator);\n        var childrenPresent = !(0, _helpers.isEmpty)(this.options) || !(0, _helpers.isEmpty)(separators);\n\n        if (!previousState.isOpen && this.state.isOpen && childrenPresent) {\n          var menuStyle = _extends({}, _select2.default.menuStyle, this.props.menuStyle);\n\n          menuNode.style.display = menuStyle.display;\n        }\n      }\n    }\n    /**\n     * Remove a component's associated styles whenever it gets removed from the DOM.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      (0, _injectStyle.removeStyle)(this._styleId);\n\n      if (_exenv.canUseDOM) {\n        document.removeEventListener('mouseup', this.mouseUpOnDocumentCallback);\n      }\n    }\n    /**\n     * Update the focusedOption based on Option the user is touching.\n     *\n     * Unfortunately updating the focusedOption only works in case the menu\n     * is not scrollable.\n     * If a setState would be triggered during a touch with the intention to\n     * scroll the setState would trigger a re-render & prevent the scrolling.\n     */\n\n    /**\n     * Identifies if the menu is scrollable.\n     */\n\n    /**\n     * Triggers a change event after the user touched on an Option.\n     */\n\n    /**\n     * Triggers a change event after the user touched on an Option.\n     */\n\n    /**\n     * Triggers a change event after the user clicked on an Option.\n     */\n\n    /**\n     * In order to inform the user which element in the document is active the\n     * component keeps track of when it's de-selected and depending on that\n     * close the menu.\n     */\n\n    /**\n     * In order to inform the user which element in the document is active the\n     * component keeps track of when it's de-selected and depending on that\n     * close the menu.\n     */\n\n    /**\n     * In order to inform the user which Option is active the component keeps\n     * track of when an option is in focus by the user and depending on that\n     * provide a visual indicator.\n     */\n\n    /**\n     * Initiate the toggle for the menu.\n     */\n\n    /**\n     * Toggle the menu after a user touched it & resets the pressed state\n     * for to toggle.\n     */\n\n    /**\n     * Reset the precondition to initialize a toggle of the menu.\n     */\n\n    /**\n     * Set isActive to true on mouse-down.\n     */\n\n    /**\n     * Set isActive to false on mouse-up.\n     */\n\n    /**\n     * Set isActive to false on mouse-up.\n     */\n\n    /**\n     * Set isActive to false on is context menu opens on select's div.\n     */\n\n    /**\n     * Update focus for the options for an already open menu.\n     *\n     * The user experience of HTML's native select is good and the goal here is to\n     * achieve the same behaviour.\n     *\n     * - Focus on the first entry in case no options is focused on.\n     * - Switch focus to the next option in case one option already has focus.\n     */\n\n    /**\n     * Update focus for the options for an already open menu.\n     *\n     * The user experience of HTML's native select is good and the goal here is to\n     * achieve the same behaviour.\n     *\n     * - Focus on the last entry in case no options is focused on.\n     * - Switch focus to the previous option in case one option already has focus.\n     */\n\n    /**\n     * After the user pressed the `Enter` or `Space` key for an already open\n     * menu the focused option is selected.\n     *\n     * Same as _onClickAtOption this update the state & dispatches a change event.\n     */\n\n    /**\n     * Manages the keyboard events.\n     *\n     * In case the Select is in focus, but closed ArrowDown, ArrowUp, Enter and\n     * Space will result in opening the menu.\n     *\n     * In case the menu is already open each key press will have\n     * different effects already documented in the related methods.\n     *\n     * Pressing Escape will close the menu.\n     */\n\n    /**\n     * Toggle the menu after a user clicked on it.\n     */\n\n  }, {\n    key: '_getIndexOfFocusedOption',\n\n    /**\n     * Returns the index of the entry with a certain value from the component's\n     * children.\n     *\n     * The index search includes only option components.\n     */\n    value: function _getIndexOfFocusedOption() {\n      var _this2 = this;\n\n      return (0, _helpers.findIndex)(this.options, function (element) {\n        return element.props.value === _this2.state.focusedOptionValue;\n      });\n    }\n    /**\n     * Returns the value of the child with a certain index.\n     */\n\n  }, {\n    key: '_getValueForIndex',\n    value: function _getValueForIndex(index) {\n      return this.options[index].props.value;\n    }\n    /**\n     * After an option has been selected the menu gets closed and the\n     * selection processed.\n     *\n     * Depending on the component's properties the value gets updated and the\n     * provided change callback for onUpdate or valueLink is called.\n     */\n\n  }, {\n    key: '_triggerChange',\n    value: function _triggerChange(value) {\n      if ((0, _helpers.has)(this.props, 'valueLink')) {\n        this.props.valueLink.requestChange(value);\n        this.setState({\n          isOpen: false\n        });\n      } else if ((0, _helpers.has)(this.props, 'value')) {\n        this.setState({\n          isOpen: false\n        });\n      } else {\n        this.setState({\n          focusedOptionValue: value,\n          selectedValue: value,\n          isOpen: false\n        });\n      }\n\n      if (this.props.onUpdate) {\n        this.props.onUpdate({\n          value: value\n        });\n      }\n    }\n  }, {\n    key: '_renderChildren',\n    value: function _renderChildren() {\n      var _this3 = this;\n\n      var optionsIndex = 0;\n      return _react2.default.Children.map(this.children, function (entry, index) {\n        if (isOption(entry)) {\n          // filter out all non-Option Components\n          var localOptionIndex = optionsIndex;\n          var isHovered = entry.props.value === _this3.state.focusedOptionValue;\n\n          var element = _react2.default.createElement(_SelectItem2.default, {\n            onItemClick: _this3._onClickAtOption,\n            onItemTouchStart: _this3._onTouchStartAtOption,\n            onItemTouchMove: _this3._onTouchMoveAtOption,\n            onItemTouchEnd: _this3._onTouchEndAtOption,\n            onItemTouchCancel: _this3._onTouchCancelAtOption,\n            onItemMouseEnter: _this3._onMouseEnterAtOption,\n            isHovered: isHovered,\n            index: localOptionIndex,\n            key: index\n          }, entry);\n\n          optionsIndex++;\n          return element;\n        } else if (isSeparator(entry)) {\n          return _react2.default.createElement('li', {\n            key: index,\n            role: 'presentation'\n          }, entry);\n        }\n\n        return null;\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var defaultStyle = _extends({}, _select2.default.style, this.props.style);\n\n      var hoverStyle = _extends({}, defaultStyle, _select2.default.hoverStyle, this.props.hoverStyle);\n\n      var focusStyle = _extends({}, defaultStyle, _select2.default.focusStyle, this.props.focusStyle);\n\n      var activeStyle = _extends({}, defaultStyle, _select2.default.activeStyle, this.props.activeStyle);\n\n      var disabledStyle = _extends({}, defaultStyle, _select2.default.disabledStyle, this.props.disabledStyle);\n\n      var disabledHoverStyle = _extends({}, disabledStyle, _select2.default.disabledHoverStyle, this.props.disabledHoverStyle);\n\n      var menuStyle = _extends({}, _select2.default.menuStyle, this.props.menuStyle);\n\n      var caretToCloseStyle = _extends({}, _select2.default.caretToCloseStyle, this.props.caretToCloseStyle);\n\n      var caretToOpenStyle = _extends({}, _select2.default.caretToOpenStyle, this.props.caretToOpenStyle);\n\n      var disabledCaretToOpenStyle = _extends({}, caretToOpenStyle, _select2.default.disabledCaretToOpenStyle, this.props.disabledCaretToOpenStyle);\n\n      var wrapperStyle = _extends({}, _select2.default.wrapperStyle, this.props.wrapperStyle);\n\n      var selectedOptionOrPlaceholder = void 0;\n\n      if (this.state.selectedValue !== void 0) {\n        var selectedEntry = (0, _helpers.find)(this.children, function (entry) {\n          return entry.props.value === _this4.state.selectedValue;\n        });\n\n        if (selectedEntry) {\n          selectedOptionOrPlaceholder = _react2.default.cloneElement(selectedEntry, {\n            _isDisplayedAsSelected: true\n          });\n        }\n      } else {\n        selectedOptionOrPlaceholder = (0, _helpers.find)(this.children, isPlaceholder);\n      }\n\n      var separators = (0, _helpers.filter)(this.children, isSeparator);\n      var childrenNotPresent = (0, _helpers.isEmpty)(this.options) && (0, _helpers.isEmpty)(separators);\n      var computedMenuStyle = this.props.disabled || !this.state.isOpen || childrenNotPresent ? {\n        display: 'none'\n      } : menuStyle;\n      var hasCustomTabIndex = this.props.wrapperProps && this.props.wrapperProps.tabIndex;\n      var tabIndex = hasCustomTabIndex ? this.props.wrapperProps.tabIndex : '0';\n      var selectedOptionWrapperStyle = void 0;\n\n      if (this.props.disabled) {\n        if (this.state.isTouchedToToggle) {\n          selectedOptionWrapperStyle = disabledHoverStyle;\n        } else {\n          selectedOptionWrapperStyle = disabledStyle;\n        }\n\n        tabIndex = -1;\n      } else {\n        if (this.state.isActive) {\n          selectedOptionWrapperStyle = activeStyle;\n        } else if (this.state.isFocused) {\n          selectedOptionWrapperStyle = focusStyle;\n        } else if (this.state.isTouchedToToggle) {\n          selectedOptionWrapperStyle = hoverStyle;\n        } else {\n          selectedOptionWrapperStyle = defaultStyle;\n        }\n      }\n\n      var caretStyle = void 0;\n\n      if (this.props.disabled) {\n        caretStyle = disabledCaretToOpenStyle;\n      } else if (this.state.isOpen) {\n        caretStyle = caretToCloseStyle;\n      } else {\n        caretStyle = caretToOpenStyle;\n      }\n\n      return _react2.default.createElement('div', _extends({\n        style: wrapperStyle,\n        tabIndex: tabIndex,\n        onKeyDown: this._onKeyDown,\n        onBlur: this._onBlur,\n        onFocus: this._onFocus,\n        ref: 'wrapper'\n      }, this.state.wrapperProps), _react2.default.createElement('div', _extends({\n        onClick: this._onClickToggleMenu,\n        onTouchStart: this._onTouchStartToggleMenu,\n        onTouchEnd: this._onTouchEndToggleMenu,\n        onTouchCancel: this._onTouchCancelToggleMenu,\n        onContextMenu: this._onContextMenu,\n        onMouseDown: this._onMouseDown,\n        onMouseUp: this._onMouseUp,\n        style: selectedOptionWrapperStyle,\n        className: (0, _unionClassNames2.default)(this.props.className, this._styleId),\n        ref: 'selectedOptionWrapper',\n        role: 'button',\n        'aria-expanded': this.state.isOpen,\n        id: this.selectedOptionWrapperId\n      }, this.state.selectedOptionWrapperProps), selectedOptionOrPlaceholder, _react2.default.createElement('span', _extends({\n        style: caretStyle\n      }, this.state.caretProps))), _react2.default.createElement('ul', _extends({\n        style: computedMenuStyle,\n        role: 'listbox',\n        'aria-labelledby': this.selectedOptionWrapperId,\n        ref: 'menu'\n      }, this.state.menuProps), this._renderChildren()));\n    }\n  }]);\n\n  return Select;\n}(_react.Component);\n\nSelect.displayName = 'Select';\nSelect.propTypes = selectPropTypes;\nSelect.childContextTypes = {\n  isDisabled: _propTypes2.default.bool.isRequired,\n  isHoveredValue: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string, _propTypes2.default.number])\n};\nSelect.defaultProps = {\n  disabled: false\n};\nexports.default = Select;","map":null,"metadata":{},"sourceType":"script"}