{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n}; // eslint-disable-line no-unused-vars\n\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _helpers = require('../utils/helpers');\n\nvar _button = require('../style/button');\n\nvar _button2 = _interopRequireDefault(_button);\n\nvar _unionClassNames = require('../utils/union-class-names');\n\nvar _unionClassNames2 = _interopRequireDefault(_unionClassNames);\n\nvar _injectStyle = require('../utils/inject-style');\n\nvar _button3 = require('../config/button');\n\nvar _button4 = _interopRequireDefault(_button3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar buttonTypes = ['button', 'submit', 'reset']; // eslint-disable-line no-unused-vars\n\nvar buttonPropTypes = {\n  activeStyle: _propTypes2.default.object,\n  children: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.node), _propTypes2.default.node]),\n  className: _propTypes2.default.string,\n  disabled: _propTypes2.default.bool,\n  type: _propTypes2.default.oneOf(buttonTypes),\n  style: _propTypes2.default.object,\n  focusStyle: _propTypes2.default.object,\n  hoverStyle: _propTypes2.default.object,\n  disabledStyle: _propTypes2.default.object,\n  disabledHoverStyle: _propTypes2.default.object,\n  onTouchStart: _propTypes2.default.func,\n  onTouchEnd: _propTypes2.default.func,\n  onTouchCancel: _propTypes2.default.func,\n  onMouseDown: _propTypes2.default.func,\n  onMouseEnter: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  onFocus: _propTypes2.default.func,\n  onBlur: _propTypes2.default.func,\n  preventFocusStyleForTouchAndClick: _propTypes2.default.bool,\n  primary: _propTypes2.default.bool\n};\n/**\n * Returns an object with properties that are relevant for the button element.\n *\n * In case a wrong or no type is defined the type of the child button will be\n * set to `button`.\n */\n\nfunction sanitizeChildProps(properties) {\n  return (0, _helpers.omit)(properties, Object.keys(buttonPropTypes));\n}\n/**\n * Update hover, focus & active style for the speficied styleId.\n *\n * @param styleId {string} - a unique id that exists as class attribute in the DOM\n * @param properties {object} - the components properties optionally containing custom styles\n */\n\n\nfunction updatePseudoClassStyle(styleId, properties, preventFocusStyleForTouchAndClick) {\n  var baseStyle = properties.primary ? _button2.default.primaryStyle : _button2.default.style;\n  var baseDisabledStyle = properties.primary ? _button2.default.primaryDisabledStyle : _button2.default.disabledStyle;\n\n  var disabledStyle = _extends({}, baseStyle, properties.style, baseDisabledStyle, properties.disabledStyle);\n\n  var baseActiveStyle = properties.primary ? _button2.default.primaryActiveStyle : _button2.default.activeStyle;\n\n  var activeStyle = _extends({}, baseActiveStyle, properties.activeStyle);\n\n  var focusStyle = void 0;\n\n  if (preventFocusStyleForTouchAndClick) {\n    focusStyle = {\n      outline: 0\n    };\n  } else {\n    var baseFocusStyle = properties.primary ? _button2.default.primaryFocusStyle : _button2.default.focusStyle;\n    focusStyle = _extends({}, baseFocusStyle, properties.focusStyle);\n  }\n\n  var styles = [{\n    id: styleId,\n    style: activeStyle,\n    pseudoClass: 'active'\n  }, {\n    id: styleId,\n    style: disabledStyle,\n    pseudoClass: 'active',\n    disabled: true\n  }, {\n    id: styleId,\n    style: focusStyle,\n    pseudoClass: 'focus'\n  }];\n  (0, _injectStyle.injectStyles)(styles);\n}\n/**\n * Button component\n *\n * The button behaves exactly like a normal html button except:\n * - Once a user clicks on the button it will loose focus\n * - By default every button is of type=\"button\" instead of \"submit\"\n */\n\n\nvar Button = function (_Component) {\n  _inherits(Button, _Component);\n\n  function Button(properties) {\n    _classCallCheck(this, Button);\n\n    var _this = _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, properties));\n\n    _this._onFocus = function (event) {\n      _this.focused = true;\n\n      _this.forceUpdate();\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(event);\n      }\n    };\n\n    _this._onBlur = function (event) {\n      _this.focused = false;\n\n      _this.setState({\n        isActive: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(event);\n      }\n    };\n\n    _this._onMouseDown = function (event) {\n      if (event.button === 0 && !_this.props.disabled) {\n        _this.mouseDownOnButton = true;\n      }\n\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(event);\n      }\n    };\n\n    _this._onTouchStart = function (event) {\n      if (!_this.props.disabled && event.touches.length === 1) {\n        _this.setState({\n          isActive: true,\n          isIgnoringHover: true\n        });\n      }\n\n      if (_this.props.onTouchStart) {\n        _this.props.onTouchStart(event);\n      }\n    };\n\n    _this._onTouchEnd = function (event) {\n      _this.setState({\n        isActive: false,\n        isIgnoringHover: true\n      });\n\n      if (_this.props.onTouchEnd) {\n        _this.props.onTouchEnd(event);\n      }\n    };\n\n    _this._onTouchCancel = function (event) {\n      _this.setState({\n        isActive: false,\n        isIgnoringHover: true\n      });\n\n      if (_this.props.onTouchEnd) {\n        _this.props.onTouchEnd(event);\n      }\n    };\n\n    _this._onMouseEnter = function (event) {\n      if (!_this.state.isIgnoringHover) {\n        _this.setState({\n          isHovered: true,\n          isIgnoringHover: false\n        });\n      }\n\n      if (_this.props.onMouseEnter) {\n        _this.props.onMouseEnter(event);\n      }\n    };\n\n    _this._onMouseLeave = function (event) {\n      _this.setState({\n        isHovered: false\n      });\n\n      if (_this.props.onMouseLeave) {\n        _this.props.onMouseLeave(event);\n      }\n    };\n\n    _this.preventFocusStyleForTouchAndClick = (0, _helpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _button4.default.preventFocusStyleForTouchAndClick;\n    _this.state = {\n      childProps: sanitizeChildProps(properties),\n      // used for touch devices like iOS Chrome/Safari where the active\n      // pseudoClass is not supported on touch\n      isActive: false,\n      isHovered: false,\n      // Note: On touch devices mouseEnter is fired while mouseLeave is not.\n      // This would result in a hover effect that keeps active until another\n      // element is focused on. This would result in the same behaviour as using\n      // the :hover pseudo class. To prevent it from happening activating the\n      // hover state is prevented when a touch event has been triggered before.\n      // source: http://stackoverflow.com/a/22444532/837709\n      isIgnoringHover: false\n    }; // The focused attribute is used to apply the one-time focus animation.\n    // As it is reset after every render it can't be set inside state as this\n    // would trigger an endless loop.\n\n    _this.focused = false; // This used to determine if the one-time focus animation should be prevented.\n\n    _this.mouseDownOnButton = false;\n    return _this;\n  }\n\n  _createClass(Button, [{\n    key: 'componentWillMount',\n\n    /**\n     * Generates the style-id & inject the focus & active style.\n     */\n    value: function componentWillMount() {\n      this.styleId = 'style-id' + (0, _helpers.uniqueId)();\n      updatePseudoClassStyle(this.styleId, this.props, this.preventFocusStyleForTouchAndClick);\n    }\n    /**\n     * Update the childProps based on the updated properties of the button.\n     */\n\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(properties) {\n      this.preventFocusStyleForTouchAndClick = (0, _helpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _button4.default.preventFocusStyleForTouchAndClick;\n      this.setState({\n        childProps: sanitizeChildProps(properties)\n      });\n      (0, _injectStyle.removeStyle)(this.styleId);\n      updatePseudoClassStyle(this.styleId, properties, this.preventFocusStyleForTouchAndClick);\n    }\n    /**\n     * Deactivate the focused attribute in order to make sure the focus animation\n     * only runs once when the component is focused on & not after re-rendering\n     * e.g when the user clicks the button.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.focused = false;\n      this.mouseDownOnButton = false;\n    }\n    /**\n     * Remove a component's associated styles whenever it gets removed from the DOM.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      (0, _injectStyle.removeStyle)(this.styleId);\n    }\n    /**\n     * Activate the focused attribute used to determine when to show the\n     * one-time focus animation and trigger a render.\n     */\n\n    /**\n     * Deactivate the focused attribute used to determine when to show the\n     * one-time focus animation and trigger a render.\n     */\n\n    /**\n     * Updates the button to be pressed.\n     */\n\n    /**\n     * Updates the button to be release.\n     */\n\n    /**\n     * Updates the button to be release.\n     */\n\n    /**\n     * As soon as the mouse enters the component the isHovered state is activated.\n     */\n\n    /**\n     * Deactivate the isHovered state.\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var baseStyle = this.props.primary ? _button2.default.primaryStyle : _button2.default.style;\n\n      var combinedStyle = _extends({}, baseStyle, this.props.style);\n\n      if (this.state.isHovered) {\n        var baseHoverStyle = this.props.primary ? _button2.default.primaryHoverStyle : _button2.default.hoverStyle;\n        combinedStyle = _extends({}, combinedStyle, baseHoverStyle, this.props.hoverStyle);\n      }\n\n      if (this.props.disabled) {\n        var baseDisabledStyle = this.props.primary ? _button2.default.primaryDisabledStyle : _button2.default.disabledStyle;\n        combinedStyle = _extends({}, combinedStyle, baseDisabledStyle, this.props.disabledStyle);\n\n        if (this.state.isHovered) {\n          var baseDisabledHoverStyle = this.props.primary ? _button2.default.primaryDisabledHoverStyle : _button2.default.disabledHoverStyle;\n          combinedStyle = _extends({}, combinedStyle, baseDisabledHoverStyle, this.props.disabledHoverStyle);\n        }\n      } else {\n        if (this.state.isActive) {\n          var baseActiveStyle = this.props.primary ? _button2.default.primaryActiveStyle : _button2.default.activeStyle;\n          combinedStyle = _extends({}, combinedStyle, baseActiveStyle, this.props.activeStyle);\n        } else if (this.focused && !this.state.isActive && !this.mouseDownOnButton && this.preventFocusStyleForTouchAndClick) {\n          var baseFocusStyle = this.props.primary ? _button2.default.primaryFocusStyle : _button2.default.focusStyle;\n          combinedStyle = _extends({}, combinedStyle, baseFocusStyle, this.props.focusStyle);\n        }\n      }\n\n      return _react2.default.createElement('button', _extends({\n        style: combinedStyle,\n        className: (0, _unionClassNames2.default)(this.props.className, this.styleId),\n        onTouchStart: this._onTouchStart,\n        onTouchEnd: this._onTouchEnd,\n        onTouchCancel: this._onTouchCancel,\n        onFocus: this._onFocus,\n        onBlur: this._onBlur,\n        onMouseDown: this._onMouseDown,\n        onMouseEnter: this._onMouseEnter,\n        onMouseLeave: this._onMouseLeave,\n        disabled: this.props.disabled,\n        type: this.props.type\n      }, this.state.childProps), this.props.children);\n    }\n  }]);\n\n  return Button;\n}(_react.Component);\n\nButton.displayName = 'Button';\nButton.propTypes = buttonPropTypes;\nButton.defaultProps = {\n  primary: false,\n  disabled: false,\n  type: 'button'\n};\nexports.default = Button;","map":null,"metadata":{},"sourceType":"script"}