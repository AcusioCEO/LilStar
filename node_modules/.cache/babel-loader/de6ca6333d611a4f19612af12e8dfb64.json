{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.has = has;\nexports.omit = omit;\nexports.filter = filter;\nexports.isArrayLike = isArrayLike;\nexports.keys = keys;\nexports.map = map;\nexports.mapObject = mapObject;\nexports.find = find;\nexports.reverse = reverse;\nexports.shift = shift;\nexports.isEmpty = isEmpty;\nexports.findIndex = findIndex;\nexports.first = first;\nexports.last = last;\nexports.size = size;\nexports.some = some;\nexports.union = union;\nexports.flatten = flatten;\nexports.filterReactChildren = filterReactChildren;\nexports.getArrayForReactChildren = getArrayForReactChildren;\nexports.flattenReactChildren = flattenReactChildren;\nexports.uniqueId = uniqueId;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Returns true if the object contain the given key.\n *\n * @param {object} obj - object to be inspected\n * @param {string} key - name of the property\n */\n\n\nfunction has(obj, key) {\n  return obj !== undefined && obj !== null && Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Return a copy of the object, filtered to omit the blacklisted keys (or array of keys).\n *\n * @param {object} obj - object the returned object is based on\n * @param {string|string[]} fields - the key or list of keys of the property to omit\n */\n\n\nfunction omit(obj, fields) {\n  if (obj) {\n    var result = {};\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key) && (!fields || fields.indexOf(key) < 0)) {\n        result[key] = obj[key];\n      }\n    }\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Looks through each value in the list, returning an array of all the values\n * that pass a truth test (predicate).\n *\n * @param {array} iterable - the iterable object to be filtered\n * @param {function} predicate - function returning true when provided with an entry as argument\n * @param {object} [context] - context for the predicate function call\n */\n\n\nfunction filter(iterable, predicate, context) {\n  if (iterable) {\n    var result = [];\n    iterable.forEach(function (obj) {\n      if (predicate && predicate.call(context, obj)) {\n        result.push(obj);\n      }\n    });\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Returns true if the provided object is an iterable, except for strings for which it will return false.\n *\n * @param {object} obj - object to be inspected\n */\n\n\nfunction isArrayLike(obj) {\n  if (Array.isArray(obj)) return true;\n  if (typeof obj === 'string') return false;\n  var length = obj.length;\n  return typeof length === 'number' && length >= 0;\n}\n/**\n * Returns all the names of the object's own properties. This will not include properties inherited through prototypes.\n *\n * @param {object} obj - object to be used\n */\n\n\nfunction keys(obj) {\n  var objKeys = [];\n\n  for (var key in obj) {\n    if (has(obj, key)) objKeys.push(key);\n  }\n\n  return objKeys;\n}\n/**\n * Returns a new array of values by mapping each value in list through a transformation function (predicate).\n *\n * @param {array} iterable - source iterable\n * @param {function} predicate - function returning the transformed array entry\n */\n\n\nfunction map(iterable, predicate) {\n  if (iterable) {\n    var result = [];\n    iterable.forEach(function (elm, index) {\n      if (predicate) {\n        result[index] = predicate(elm, index);\n      }\n    });\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Returns a new object by mapping each property in an object through a transformation function (predicate).\n *\n * @param {object} obj - object to be based upon\n * @param {function} predicate - function to transform the property\n */\n\n\nfunction mapObject(obj, predicate) {\n  if (obj) {\n    var result = [];\n    var objKeys = keys(obj);\n    objKeys.forEach(function (key, index) {\n      if (predicate) {\n        result[index] = predicate(obj[key], key);\n      }\n    });\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Returns the first value that passes a truth test (predicate), or undefined if\n * no value passes the test. Only works for iterable objects e.g. arrays.\n *\n * @param {array} iterable - the iterable object to be searched\n * @param {function} predicate - function returning true in case of a positive match\n * @param {object} [context] - context for the predicate function call\n */\n\n\nfunction find(iterable, predicate, context) {\n  if (iterable) {\n    var result = void 0;\n\n    for (var index = 0; index < iterable.length; index++) {\n      if (predicate && predicate.call(context, iterable[index])) {\n        result = iterable[index];\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Reverse the array passed to it.\n * @param {array} iterable - the array to be reversed.\n */\n\n\nfunction reverse(iterable) {\n  if (iterable) {\n    var result = [];\n\n    for (var index = iterable.length - 1; index >= 0; index--) {\n      result.push(iterable[index]);\n    }\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Shifts given array by given number of positions.\n * @param {array} iterable - the array to be shifted.\n * @param {array} positions - number of positions shifting is needed.\n */\n\n\nfunction shift(iterable, positions) {\n  if (iterable) {\n    if (positions && positions > 0) {\n      var result = [];\n      var arrayLength = iterable.length;\n\n      for (var index = 0; index < iterable.length; index++) {\n        result.push(iterable[(index + positions) % arrayLength]);\n      }\n\n      return result;\n    }\n\n    return iterable;\n  }\n\n  return undefined;\n}\n/**\n * Returns true if object contains no values (no enumerable own-properties).\n *\n * @param {Object} obj - an object\n */\n\n\nfunction isEmpty(obj) {\n  return !obj || Array.isArray(obj) && obj.length === 0 || Object.keys(obj).length === 0;\n}\n/**\n * Returns the index of the first value that passes a truth test (predicate), or undefined if\n * no value passes the test. Only works for iterable objects e.g. arrays.\n *\n * @param {array} iterable - the iterable object to be searched\n * @param {function} predicate - function returning true in case of a positive match\n * @param {object} [context] - context for the predicate function call\n */\n\n\nfunction findIndex(iterable, predicate, context) {\n  if (iterable) {\n    var result = void 0;\n\n    for (var index = 0; index < iterable.length; index++) {\n      if (predicate && predicate.call(context, iterable[index])) {\n        result = index;\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Returns the first element of an iterable object.\n *\n * @param {array} iterable - must be an iterable object\n */\n\n\nfunction first(iterable) {\n  if (iterable && iterable.length > 0) {\n    return iterable[0];\n  }\n\n  return undefined;\n}\n/**\n * Returns the last element of an iterable object.\n *\n * @param {array} iterable - must be an iterable object\n */\n\n\nfunction last(iterable) {\n  if (iterable && iterable.length > 0) {\n    return iterable[iterable.length - 1];\n  }\n\n  return undefined;\n}\n/**\n * Return the number of values in the list.\n *\n * @param {array} iterable - must be an iterable object\n */\n\n\nfunction size(iterable) {\n  if (iterable) {\n    return iterable.length;\n  }\n\n  return 0;\n}\n/**\n * Returns true if any of the values in the list pass the predicate truth test.\n *\n * @param {array} iterable - iterable object to be searched\n * @param {function} predicate - function returning true in case of a positive match\n * @param {object} [context] - context for the predicate function call\n */\n\n\nfunction some(iterable, predicate, context) {\n  if (iterable) {\n    var result = void 0;\n\n    for (var index = 0; index < iterable.length; index++) {\n      if (predicate && predicate.call(context, iterable[index])) {\n        result = true;\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Returns the union of the passed-in arrays: the list of unique items, in order, that are present in one or more of the arrays.\n *\n * @param {...array} arrs - at least two iterable objects must be provide\n */\n\n\nfunction union() {\n  for (var _len = arguments.length, arrs = Array(_len), _key = 0; _key < _len; _key++) {\n    arrs[_key] = arguments[_key];\n  }\n\n  if (arrs) {\n    var result = [];\n    arrs.forEach(function (arr) {\n      if (arr) {\n        arr.forEach(function (obj) {\n          if (result.indexOf(obj) < 0) {\n            result.push(obj);\n          }\n        });\n      }\n    });\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Recursive function for flattening an iterable.\n *\n * @param {object} output - base object to be updated\n * @param {object} element - input object to be merged into the output\n */\n\n\nfunction flattenInternal(output, element) {\n  if (element) {\n    element.forEach(function (obj) {\n      if (Array.isArray(obj)) {\n        flattenInternal(output, obj);\n      } else {\n        output.push(obj);\n      }\n    });\n  }\n}\n/**\n * Flattens a nested array (the nesting can be to any depth).\n *\n * @param {...array} arrays - at least one array must be provided\n */\n\n\nfunction flatten() {\n  for (var _len2 = arguments.length, arrays = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = arguments[_key2];\n  }\n\n  if (arrays) {\n    var result = [];\n    flattenInternal(result, arrays);\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Looks through a collection of React children elements, filtering them according to the predicate passed.\n *\n * @param {Array/Object} children - colleciton of >=1 react elements\n * @param {function} predicate - function returning true when provided with an entry as argument\n */\n\n\nfunction filterReactChildren(children, predicate) {\n  var _this = this;\n\n  if (children) {\n    var result = [];\n\n    _react2.default.Children.forEach(children, function (entry) {\n      if (predicate && predicate.call(_this, entry)) {\n        result.push(entry);\n      }\n    });\n\n    return result;\n  }\n\n  return undefined;\n}\n/**\n * Looks through a collection of React children elements, filtering them according to the predicate passed.\n *\n * @param {Array/Object} children - collection of >=1 react elements\n */\n\n\nfunction getArrayForReactChildren(children) {\n  if (children) {\n    var result = [];\n\n    _react2.default.Children.forEach(children, function (entry) {\n      result.push(entry);\n    });\n\n    return result;\n  }\n\n  return undefined;\n}\n\nfunction flattenReactChildren(children) {\n  if (!isEmpty(children)) {\n    if (Array.isArray(children)) {\n      return flatten(children);\n    }\n\n    return getArrayForReactChildren(children);\n  }\n\n  return undefined;\n}\n\nfunction uniqueId() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}","map":null,"metadata":{},"sourceType":"script"}