{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _injectStyle = require('../utils/inject-style');\n\nvar _helpers = require('../utils/helpers');\n\nvar _toggle = require('../style/toggle');\n\nvar _toggle2 = _interopRequireDefault(_toggle);\n\nvar _toggle3 = require('../config/toggle');\n\nvar _toggle4 = _interopRequireDefault(_toggle3);\n\nvar _isComponentOfType = require('../utils/is-component-of-type.js');\n\nvar _isComponentOfType2 = _interopRequireDefault(_isComponentOfType);\n\nvar _animationFrameManagement = require('../utils/animation-frame-management');\n\nvar _unionClassNames = require('../utils/union-class-names');\n\nvar _unionClassNames2 = _interopRequireDefault(_unionClassNames);\n\nvar _Choice = require('../components/Choice');\n\nvar _Choice2 = _interopRequireDefault(_Choice);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * Verifies that the children is an array containing only two choices with a\n * different value.\n */\n\n\nfunction validateChoices(props, propName, componentName) {\n  var propValue = props[propName];\n\n  if (!propValue) {\n    return undefined;\n  }\n\n  if (!Array.isArray(propValue) || propValue.length !== 2) {\n    return new Error('Invalid ' + propName + ' supplied to `' + componentName + '`, expected exactly two Choice components.');\n  }\n\n  for (var i = 0; i < propValue.length; ++i) {\n    var item = propValue[i];\n\n    if (!item || !(0, _isComponentOfType2.default)(_Choice2.default, item)) {\n      return new Error('Invalid ' + propName + '[' + i + '] supplied to `' + componentName + '`, expected a Choice component from Belle.');\n    }\n  }\n\n  if ((0, _helpers.first)(propValue).props.value === (0, _helpers.last)(propValue).props.value) {\n    return new Error('Invalid ' + propName + ' supplied to `' + componentName + '`, expected different value properties for the provided Choice components.');\n  }\n\n  return undefined;\n}\n\nvar togglePropTypes = {\n  activeHandleStyle: _propTypes2.default.object,\n  children: validateChoices,\n  className: _propTypes2.default.string,\n  defaultValue: _propTypes2.default.bool,\n  disabled: _propTypes2.default.bool,\n  disabledHandleStyle: _propTypes2.default.object,\n  disabledStyle: _propTypes2.default.object,\n  firstChoiceProps: _propTypes2.default.object,\n  firstChoiceStyle: _propTypes2.default.shape({\n    width: _propTypes2.default.number\n  }),\n  focusStyle: _propTypes2.default.object,\n  handleProps: _propTypes2.default.shape({\n    onMouseDown: _propTypes2.default.func,\n    onMouseMove: _propTypes2.default.func,\n    onMouseUp: _propTypes2.default.func,\n    onMouseLeave: _propTypes2.default.func,\n    onTouchStart: _propTypes2.default.func,\n    onTouchMove: _propTypes2.default.func,\n    onTouchEnd: _propTypes2.default.func,\n    onTouchCancel: _propTypes2.default.func\n  }),\n  handleStyle: _propTypes2.default.shape({\n    height: _propTypes2.default.number,\n    width: _propTypes2.default.number\n  }),\n  hoverHandleStyle: _propTypes2.default.object,\n  onBlur: _propTypes2.default.func,\n  onUpdate: _propTypes2.default.func,\n  onFocus: _propTypes2.default.func,\n  onKeyDown: _propTypes2.default.func,\n  onMouseDown: _propTypes2.default.func,\n  onMouseEnter: _propTypes2.default.func,\n  onMouseLeave: _propTypes2.default.func,\n  onMouseUp: _propTypes2.default.func,\n  onTouchStart: _propTypes2.default.func,\n  secondChoiceProps: _propTypes2.default.object,\n  secondChoiceStyle: _propTypes2.default.shape({\n    width: _propTypes2.default.number\n  }),\n  sliderProps: _propTypes2.default.shape({\n    onClick: _propTypes2.default.func,\n    onTouchStart: _propTypes2.default.func,\n    onTouchMove: _propTypes2.default.func,\n    onTouchEnd: _propTypes2.default.func,\n    onTouchCancel: _propTypes2.default.func\n  }),\n  sliderStyle: _propTypes2.default.object,\n  sliderWrapperProps: _propTypes2.default.object,\n  sliderWrapperStyle: _propTypes2.default.object,\n  style: _propTypes2.default.shape({\n    width: _propTypes2.default.number\n  }),\n  value: _propTypes2.default.bool,\n  valueLink: _propTypes2.default.shape({\n    value: _propTypes2.default.bool.isRequired,\n    requestChange: _propTypes2.default.func.isRequired\n  }),\n  wrapperProps: _propTypes2.default.object\n};\n\nfunction sanitizeChildProps(properties) {\n  return (0, _helpers.omit)(properties, Object.keys(togglePropTypes));\n}\n\nfunction sanitizeSliderProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel']);\n}\n\nfunction sanitizeSliderWrapperProps(properties) {\n  return (0, _helpers.omit)(properties, ['ref', 'style']);\n}\n\nfunction sanitizeChoiceProps(properties) {\n  return (0, _helpers.omit)(properties, ['ref', 'style']);\n}\n\nfunction sanitizeHandleProps(properties) {\n  return (0, _helpers.omit)(properties, ['onMouseDown', 'onMouseMove', 'onMouseUp', 'onMouseLeave', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel', 'ref', 'style']);\n}\n/**\n * Update focus style for the speficied styleId.\n *\n * @param styleId {string} - a unique id that exists as class attribute in the DOM\n * @param properties {object} - the components properties optionally containing custom styles\n */\n\n\nfunction updatePseudoClassStyle(styleId, properties, preventFocusStyleForTouchAndClick) {\n  var focusStyle = void 0;\n\n  if (preventFocusStyleForTouchAndClick) {\n    focusStyle = {\n      outline: 0\n    };\n  } else {\n    focusStyle = _extends({}, _toggle2.default.focusStyle, properties.focusStyle);\n  }\n\n  var styles = [{\n    id: styleId,\n    style: focusStyle,\n    pseudoClass: 'focus'\n  }];\n  (0, _injectStyle.injectStyles)(styles);\n}\n/**\n * Toggle component\n */\n\n\nvar Toggle = function (_Component) {\n  _inherits(Toggle, _Component);\n\n  function Toggle(properties) {\n    _classCallCheck(this, Toggle);\n\n    var _this = _possibleConstructorReturn(this, (Toggle.__proto__ || Object.getPrototypeOf(Toggle)).call(this, properties));\n\n    _initialiseProps.call(_this);\n\n    var value = void 0;\n\n    if ((0, _helpers.has)(properties, 'valueLink')) {\n      value = properties.valueLink.value;\n    } else if ((0, _helpers.has)(properties, 'value')) {\n      value = properties.value;\n    } else if ((0, _helpers.has)(properties, 'defaultValue')) {\n      value = properties.defaultValue;\n    } else {\n      value = false;\n    }\n\n    _this.state = {\n      firstChoiceProps: sanitizeChoiceProps(properties.firstChoiceProps),\n      childProps: sanitizeChildProps(properties),\n      secondChoiceProps: sanitizeChoiceProps(properties.secondChoiceProps),\n      handleProps: sanitizeHandleProps(properties.handleProps),\n      isActive: false,\n      isDraggingWithMouse: false,\n      isDraggingWithTouch: false,\n      sliderProps: sanitizeSliderProps(properties.sliderProps),\n      sliderWrapperProps: sanitizeSliderWrapperProps(properties.sliderWrapperProps),\n      value: value,\n      wasFocusedWithClickOrTouch: false\n    };\n    _this._touchStartedAtSlider = false;\n    _this._touchEndedNotInSlider = false;\n    _this._preventTouchSwitch = false;\n    _this._mouseDragStart = undefined;\n    _this._mouseDragEnd = undefined;\n    _this._preventMouseSwitch = false; // The isFocused attribute is used to apply the one-time focus animation.\n    // As it is reset after every render it can't be set inside state as this\n    // would trigger an endless loop.\n\n    _this.isFocused = false;\n    _this.preventFocusStyleForTouchAndClick = (0, _helpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _toggle4.default.preventFocusStyleForTouchAndClick;\n    return _this;\n  }\n\n  _createClass(Toggle, [{\n    key: 'componentWillMount',\n\n    /**\n     * Generates the style-id & inject the focus style.\n     */\n    value: function componentWillMount() {\n      var id = (0, _helpers.uniqueId)();\n      this.styleId = 'style-id' + id;\n      updatePseudoClassStyle(this.styleId, this.props, this.preventFocusStyleForTouchAndClick);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(properties) {\n      var newState = {\n        firstChoiceProps: sanitizeChoiceProps(properties.firstChoiceProps),\n        childProps: sanitizeChildProps(properties),\n        secondChoiceProps: sanitizeChoiceProps(properties.secondChoiceProps),\n        handleProps: sanitizeHandleProps(properties.handleProps),\n        sliderProps: sanitizeSliderProps(properties.sliderProps),\n        sliderWrapperProps: sanitizeSliderWrapperProps(properties.sliderWrapperProps)\n      };\n\n      if ((0, _helpers.has)(properties, 'valueLink')) {\n        newState.value = properties.valueLink.value;\n      } else if ((0, _helpers.has)(properties, 'value')) {\n        newState.value = properties.value;\n      }\n\n      this.setState(newState);\n      this.preventFocusStyleForTouchAndClick = (0, _helpers.has)(properties, 'preventFocusStyleForTouchAndClick') ? properties.preventFocusStyleForTouchAndClick : _toggle4.default.preventFocusStyleForTouchAndClick;\n      (0, _injectStyle.removeStyle)(this.styleId);\n      updatePseudoClassStyle(this.styleId, properties, this.preventFocusStyleForTouchAndClick);\n    }\n    /**\n     * Deactivate the focused attribute in order to make sure the focus animation\n     * only runs once when the component is focused on & not after re-rendering\n     * e.g when the user clicks on the toggle.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.isFocused = false;\n    }\n    /**\n     * Remove a component's associated styles whenever it gets removed from the DOM.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      (0, _injectStyle.removeStyle)(this.styleId);\n    }\n    /**\n     * Activate the focused attribute used to determine when to show the\n     * one-time focus animation and trigger a render.\n     */\n\n    /**\n     * Deactivate the focused attribute used to determine when to show the\n     * one-time focus animation and trigger a render.\n     */\n\n  }, {\n    key: '_onArrowLeftKeyDown',\n\n    /**\n     * Flip value in case it is false.\n     */\n    value: function _onArrowLeftKeyDown() {\n      if (this.state.value === true) {\n        this._triggerChange(false);\n      }\n    }\n    /**\n     * Flip value in case it is true.\n     */\n\n  }, {\n    key: '_onArrowRightKeyDown',\n    value: function _onArrowRightKeyDown() {\n      if (this.state.value === false) {\n        this._triggerChange(true);\n      }\n    }\n    /**\n     * Flip value and trigger change.\n     */\n\n  }, {\n    key: '_onEnterOrSpaceKeyDown',\n    value: function _onEnterOrSpaceKeyDown() {\n      this._triggerChange(!this.state.value);\n    }\n  }, {\n    key: '_getHandleHeight',\n    value: function _getHandleHeight() {\n      return (0, _helpers.has)(this.props.handleStyle, 'height') ? this.props.handleStyle.height : _toggle2.default.handleStyle.height;\n    }\n  }, {\n    key: '_getHandleWidth',\n    value: function _getHandleWidth() {\n      return (0, _helpers.has)(this.props.handleStyle, 'width') ? this.props.handleStyle.width : _toggle2.default.handleStyle.width;\n    }\n  }, {\n    key: '_getSliderOffset',\n    value: function _getSliderOffset() {\n      var firstChoiceWidth = (0, _helpers.has)(this.props.firstChoiceStyle, 'width') ? this.props.firstChoiceStyle.width : _toggle2.default.firstChoiceStyle.width;\n      return firstChoiceWidth - this._getHandleWidth() / 2;\n    }\n  }, {\n    key: '_getToggleWidth',\n    value: function _getToggleWidth() {\n      return (0, _helpers.has)(this.props.style, 'width') ? this.props.style.width : _toggle2.default.style.width;\n    }\n  }, {\n    key: '_triggerChange',\n    value: function _triggerChange(value) {\n      if ((0, _helpers.has)(this.props, 'valueLink')) {\n        this.props.valueLink.requestChange(value);\n        this.setState({\n          isDraggingWithMouse: false,\n          isDraggingWithTouch: false,\n          isActive: false\n        });\n      } else if ((0, _helpers.has)(this.props, 'value')) {\n        this.setState({\n          isDraggingWithMouse: false,\n          isDraggingWithTouch: false,\n          isActive: false\n        });\n      } else {\n        this.setState({\n          value: value,\n          isDraggingWithMouse: false,\n          isDraggingWithTouch: false,\n          isActive: false\n        });\n      }\n\n      if (this.props.onUpdate) {\n        this.props.onUpdate({\n          value: value\n        });\n      }\n    }\n  }, {\n    key: '_triggerUpdateComponentOnMouseMove',\n    value: function _triggerUpdateComponentOnMouseMove(pageX) {\n      var difference = pageX - this._mouseDragStart;\n\n      if (this.state.value && this._mouseDragEnd && difference > this._mouseDragEnd) {\n        this._preventMouseSwitch = true;\n      } else if (!this.state.value && this._mouseDragEnd && difference < this._mouseDragEnd) {\n        this._preventMouseSwitch = true;\n      }\n\n      this._mouseDragEnd = difference;\n      if (difference < 0 || difference > this._getToggleWidth() - this._getHandleWidth()) return;\n      this.setState({\n        sliderOffset: difference\n      });\n    }\n  }, {\n    key: '_triggerUpdateComponentOnTouchMoveAtSlider',\n    value: function _triggerUpdateComponentOnTouchMoveAtSlider(touch) {\n      var touchedElement = document.elementFromPoint(touch.clientX, touch.clientY);\n\n      var firstChoiceNode = _reactDom2.default.findDOMNode(this.refs.firstChoice);\n\n      var secondChoiceNode = _reactDom2.default.findDOMNode(this.refs.secondChoice);\n\n      this._touchEndedNotInSlider = touchedElement !== firstChoiceNode && touchedElement !== secondChoiceNode;\n\n      if (this.state.isActive && this._touchEndedNotInSlider) {\n        this.setState({\n          isActive: false\n        });\n      } else if (!this.state.isActive && !this._touchEndedNotInSlider) {\n        this.setState({\n          isActive: true\n        });\n      }\n    }\n  }, {\n    key: '_triggerUpdateComponentOnTouchMoveAtHandle',\n    value: function _triggerUpdateComponentOnTouchMoveAtHandle(touch) {\n      var sliderWrapperNode = _reactDom2.default.findDOMNode(this.refs.sliderWrapper);\n\n      var rect = sliderWrapperNode.getBoundingClientRect();\n      var difference = touch.pageX - this._touchDragStart;\n      var horizontalTolerance = this._getHandleWidth() * 2;\n      var verticalTolerance = this._getHandleHeight() * 2; // touch left the allowed handle drag area\n\n      if (touch.clientX < rect.left - horizontalTolerance || touch.clientX > rect.right + horizontalTolerance || touch.clientY < rect.top - verticalTolerance || touch.clientY > rect.bottom + verticalTolerance) {\n        if (this._preventTouchSwitch) {\n          var value = difference > this._getHandleWidth() / 2;\n\n          this._triggerChange(value);\n        } else {\n          this._triggerChange(!this.state.value);\n        }\n      } else if (this.state.isDraggingWithTouch) {\n        // is still dragging\n        if (this.state.value && this._touchDragEnd && difference > this._touchDragEnd) {\n          this._preventTouchSwitch = true;\n        } else if (!this.state.value && this._touchDragEnd && difference < this._touchDragEnd) {\n          this._preventTouchSwitch = true;\n        }\n\n        if (difference < 0 || difference > this._getToggleWidth() - this._getHandleWidth()) return;\n        this._touchDragEnd = difference;\n        this.setState({\n          sliderOffset: difference\n        });\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var wrapperStyle = _extends({}, _toggle2.default.style, this.props.style);\n\n      if (this.isFocused && !this.state.wasFocusedWithClickOrTouch) {\n        wrapperStyle = _extends({}, wrapperStyle, _toggle2.default.focusStyle, this.props.focusStyle);\n      }\n\n      var computedSliderStyle = void 0;\n      var handleStyle = void 0;\n\n      var sliderWrapperStyle = _extends({}, _toggle2.default.sliderWrapperStyle, this.props.sliderWrapperStyle);\n\n      var defaultSliderOffset = this._getSliderOffset();\n\n      if (this.state.isDraggingWithMouse || this.state.isDraggingWithTouch) {\n        computedSliderStyle = _extends({}, _toggle2.default.sliderStyle, this.props.sliderStyle, {\n          left: this.state.sliderOffset - defaultSliderOffset,\n          transition: 'none'\n        }); // right now even when handle is clicked, it momentarily shows this grabbing styles\n        // may be this.state.isDraggingWithMouse should be set to true only after mouse movement starts\n\n        var activeStyle = _extends({}, _toggle2.default.activeHandleStyle, this.props.handleStyle);\n\n        handleStyle = _extends({}, _toggle2.default.handleStyle, activeStyle, this.props.activeHandleStyle, {\n          left: this.state.sliderOffset,\n          transition: activeStyle.transition ? activeStyle.transition : 'none'\n        });\n      } else {\n        handleStyle = _extends({}, _toggle2.default.handleStyle, this.props.handleStyle);\n        computedSliderStyle = _extends({}, _toggle2.default.sliderStyle, {\n          left: this.state.value ? 0 : -defaultSliderOffset\n        });\n\n        if (this.state.isActive) {\n          handleStyle = _extends({}, handleStyle, _toggle2.default.activeHandleStyle, this.props.activeHandleStyle);\n        } else if (this.state.isHovered) {\n          handleStyle = _extends({}, handleStyle, _toggle2.default.hoverHandleStyle, this.props.hoverHandleStyle);\n        }\n\n        var position = {\n          left: this.state.value ? defaultSliderOffset : 0\n        };\n        handleStyle = _extends({}, handleStyle, position);\n      }\n\n      var computedTrueChoice = (0, _helpers.first)(this.props.children) ? (0, _helpers.first)(this.props.children) : '✓';\n      var computedFalseChoice = (0, _helpers.last)(this.props.children) ? (0, _helpers.last)(this.props.children) : '✘';\n\n      var computedTrueChoiceStyle = _extends({}, _toggle2.default.firstChoiceStyle, this.props.firstChoiceStyle);\n\n      var computedFalseChoiceStyle = _extends({}, _toggle2.default.secondChoiceStyle, this.props.secondChoiceStyle);\n\n      var hasCustomTabIndex = this.props.wrapperProps && this.props.wrapperProps.tabIndex;\n      var tabIndex = hasCustomTabIndex ? this.props.wrapperProps.tabIndex : '0';\n\n      if (this.props.disabled) {\n        tabIndex = -1;\n        wrapperStyle = _extends({}, wrapperStyle, _toggle2.default.disabledStyle, this.props.disabledStyle);\n        handleStyle = _extends({}, handleStyle, _toggle2.default.disabledHandleStyle, this.props.disabledHandleStyle);\n      }\n\n      var role = (0, _helpers.has)(this.state.childProps, 'role') ? this.state.childProps.role : 'checkbox';\n      return _react2.default.createElement('div', _extends({\n        style: wrapperStyle,\n        tabIndex: tabIndex,\n        className: (0, _unionClassNames2.default)(this.props.className, this.styleId),\n        onKeyDown: this._onKeyDown,\n        onMouseDown: this._onMouseDownOnWrapper,\n        onMouseUp: this._onMouseUpOnWrapper,\n        onTouchStart: this._onTouchStartOnWrapper,\n        onFocus: this._onFocus,\n        onBlur: this._onBlur,\n        onMouseEnter: this._onMouseEnterAtSliderWrapper,\n        onMouseLeave: this._onMouseLeaveAtSliderWrapper,\n        role: role,\n        'aria-checked': this.state.value\n      }, this.state.childProps), _react2.default.createElement('div', _extends({\n        style: sliderWrapperStyle,\n        ref: 'sliderWrapper'\n      }, this.state.sliderWrapperProps), _react2.default.createElement('div', _extends({\n        style: computedSliderStyle,\n        onClick: this._onClickAtSlider,\n        onTouchStart: this._onTouchStartAtSlider,\n        onTouchMove: this._onTouchMoveAtSlider,\n        onTouchEnd: this._onTouchEndAtSlider,\n        onTouchCancel: this._onTouchCancelAtSlider\n      }, this.state.sliderProps), _react2.default.createElement('div', _extends({\n        ref: 'firstChoice',\n        style: computedTrueChoiceStyle\n      }, this.state.firstChoiceProps), computedTrueChoice), _react2.default.createElement('div', _extends({\n        ref: 'secondChoice',\n        style: computedFalseChoiceStyle\n      }, this.state.secondChoiceProps), computedFalseChoice))), _react2.default.createElement('div', _extends({\n        ref: 'handle',\n        style: handleStyle,\n        onMouseDown: this._onMouseDownOnHandle,\n        onMouseMove: this._onMouseMoveOnHandle,\n        onMouseUp: this._onMouseUpOnHandle,\n        onMouseLeave: this._onMouseLeaveOnHandle,\n        onTouchStart: this._onTouchStartHandle,\n        onTouchMove: this._onTouchMoveHandle,\n        onTouchEnd: this._onTouchEndHandle,\n        onTouchCancel: this._onTouchCancelHandle\n      }, this.state.handleProps)));\n    }\n  }]);\n\n  return Toggle;\n}(_react.Component);\n\nToggle.displayName = 'Toggle';\nToggle.propTypes = togglePropTypes;\nToggle.defaultProps = {\n  disabled: false\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._onFocus = function (event) {\n    if (!_this2.props.disabled) {\n      _this2.isFocused = true;\n\n      _this2.forceUpdate();\n    }\n\n    if (_this2.props.onFocus) {\n      _this2.props.onFocus(event);\n    }\n  };\n\n  this._onBlur = function (event) {\n    _this2.isFocused = false;\n\n    _this2.setState({\n      wasFocusedWithClickOrTouch: false\n    });\n\n    if (_this2.props.onBlur) {\n      _this2.props.onBlur(event);\n    }\n  };\n\n  this._onMouseDownOnWrapper = function (event) {\n    if (!_this2.props.disabled) {\n      _this2.setState({\n        wasFocusedWithClickOrTouch: true,\n        isActive: true\n      });\n    }\n\n    if (_this2.props.onMouseDown) {\n      _this2.props.onMouseDown(event);\n    }\n  };\n\n  this._onMouseUpOnWrapper = function (event) {\n    if (!_this2.props.disabled) {\n      _this2.setState({\n        isActive: false\n      });\n    }\n\n    if (_this2.props.onMouseUp) {\n      _this2.props.onMouseUp(event);\n    }\n  };\n\n  this._onTouchStartOnWrapper = function (event) {\n    if (!_this2.props.disabled) {\n      _this2.setState({\n        wasFocusedWithClickOrTouch: true\n      });\n    }\n\n    if (_this2.props.onTouchStart) {\n      _this2.props.onTouchStart(event);\n    }\n  };\n\n  this._onClickAtSlider = function (event) {\n    if (!_this2.props.disabled) {\n      _this2._triggerChange(!_this2.state.value);\n    }\n\n    if (_this2.props.sliderProps && _this2.props.sliderProps.onClick) {\n      _this2.props.sliderProps.onClick(event);\n    }\n  };\n\n  this._onMouseDownOnHandle = function (event) {\n    // check for left mouse button pressed\n    if (event.button === 0 && !_this2.props.disabled) {\n      var defaultSliderOffset = _this2._getSliderOffset();\n\n      _this2._mouseDragStart = event.pageX - (_this2.state.value ? defaultSliderOffset : 0);\n      _this2._preventMouseSwitch = false;\n\n      _this2.setState({\n        isDraggingWithMouse: true,\n        sliderOffset: _this2.state.value ? defaultSliderOffset : 0\n      });\n    }\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onMouseDown) {\n      _this2.props.handleProps.onMouseDown(event);\n    }\n  };\n\n  this._onMouseMoveOnHandle = function (event) {\n    if (_this2.state.isDraggingWithMouse && !_this2.props.disabled) {\n      // the requestAnimationFrame function must be executed in the context of window\n      // see http://stackoverflow.com/a/9678166/837709\n      var animationFrame = _animationFrameManagement.requestAnimationFrame.call(window, _this2._triggerUpdateComponentOnMouseMove.bind(_this2, event.pageX));\n\n      if (_this2.previousMouseMoveFrame) {\n        // the cancelAnimationFrame function must be executed in the context of window\n        // see http://stackoverflow.com/a/9678166/837709\n        _animationFrameManagement.cancelAnimationFrame.call(window, _this2.previousMouseMoveFrame);\n      }\n\n      _this2.previousMouseMoveFrame = animationFrame;\n    }\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onMouseMove) {\n      _this2.props.handleProps.onMouseMove(event);\n    }\n  };\n\n  this._onMouseUpOnHandle = function (event) {\n    if (!_this2.props.disabled) {\n      if (_this2._mouseDragEnd) {\n        if (!_this2._preventMouseSwitch) {\n          _this2._triggerChange(!_this2.state.value);\n        } else if (_this2._preventMouseSwitch) {\n          var value = _this2._mouseDragEnd > _this2._getHandleWidth() / 2;\n\n          _this2._triggerChange(value);\n        }\n      } else {\n        _this2._triggerChange(!_this2.state.value);\n      }\n    }\n\n    _this2._mouseDragStart = undefined;\n    _this2._mouseDragEnd = undefined;\n    _this2._preventMouseSwitch = false;\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onMouseUp) {\n      _this2.props.handleProps.onMouseUp(event);\n    }\n  };\n\n  this._onMouseLeaveOnHandle = function (event) {\n    if (!_this2.props.disabled) {\n      if (_this2._mouseDragStart && !_this2._preventMouseSwitch) {\n        _this2._triggerChange(!_this2.state.value);\n      } else if (_this2._mouseDragStart && _this2._preventMouseSwitch) {\n        var value = _this2._mouseDragEnd > _this2._getHandleWidth() / 2;\n\n        _this2._triggerChange(value);\n      } else {\n        _this2.setState({\n          isActive: false\n        });\n      }\n    }\n\n    _this2._mouseDragStart = undefined;\n    _this2._mouseDragEnd = undefined;\n    _this2._preventMouseSwitch = false;\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onMouseLeave) {\n      _this2.props.handleProps.onMouseLeave(event);\n    }\n  };\n\n  this._onTouchStartAtSlider = function (event) {\n    if (event.touches.length === 1 && !_this2.props.disabled) {\n      _this2._touchStartedAtSlider = true;\n\n      _this2.setState({\n        isActive: true\n      });\n    }\n\n    if (_this2.props.sliderProps && _this2.props.sliderProps.onTouchStart) {\n      _this2.props.sliderProps.onTouchStart(event);\n    }\n  };\n\n  this._onTouchMoveAtSlider = function (event) {\n    if (event.touches.length === 1 && _this2._touchStartedAtSlider && !_this2.props.disabled) {\n      // the requestAnimationFrame function must be executed in the context of window\n      // see http://stackoverflow.com/a/9678166/837709\n      var animationFrame = _animationFrameManagement.requestAnimationFrame.call(window, _this2._triggerUpdateComponentOnTouchMoveAtSlider.bind(_this2, event.touches[0]));\n\n      if (_this2.previousTouchMoveAtSliderFrame) {\n        // the cancelAnimationFrame function must be executed in the context of window\n        // see http://stackoverflow.com/a/9678166/837709\n        _animationFrameManagement.cancelAnimationFrame.call(window, _this2.previousTouchMoveAtSliderFrame);\n      }\n\n      _this2.previousTouchMoveAtSliderFrame = animationFrame;\n    }\n\n    if (_this2.props.sliderProps && _this2.props.sliderProps.onTouchMove) {\n      _this2.props.sliderProps.onTouchMove(event);\n    }\n  };\n\n  this._onTouchEndAtSlider = function (event) {\n    // prevent the onClick to happen\n    event.preventDefault();\n\n    if (_this2._touchStartedAtSlider && !_this2._touchEndedNotInSlider && !_this2.props.disabled) {\n      _this2.setState({\n        isActive: false\n      });\n\n      _this2._triggerChange(!_this2.state.value);\n    } else {\n      _this2.setState({\n        isActive: false\n      });\n    }\n\n    _this2._touchStartedAtSlider = false;\n    _this2._touchEndedNotInSlider = false;\n\n    if (_this2.props.sliderProps && _this2.props.sliderProps.onTouchEnd) {\n      _this2.props.sliderProps.onTouchEnd(event);\n    }\n  };\n\n  this._onTouchCancelAtSlider = function (event) {\n    _this2.setState({\n      isActive: false\n    });\n\n    _this2._touchStartedAtSlider = false;\n    _this2._touchEndedNotInSlider = false;\n\n    if (_this2.props.sliderProps && _this2.props.sliderProps.onTouchCancel) {\n      _this2.props.sliderProps.onTouchCancel(event);\n    }\n  };\n\n  this._onTouchStartHandle = function (event) {\n    event.preventDefault(); // check for one touch as multiple could be browser gestures and only one\n    // is relevant for us\n\n    if (event.touches.length === 1 && !_this2.props.disabled) {\n      _this2._preventTouchSwitch = false;\n\n      var defaultSliderOffset = _this2._getSliderOffset();\n\n      _this2.setState({\n        isDraggingWithTouch: true,\n        sliderOffset: _this2.state.value ? defaultSliderOffset : 0\n      });\n\n      _this2._touchDragStart = event.touches[0].pageX - (_this2.state.value ? defaultSliderOffset : 0);\n    }\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onTouchStart) {\n      _this2.props.handleProps.onTouchStart(event);\n    }\n  };\n\n  this._onTouchMoveHandle = function (event) {\n    if (event.touches.length === 1 && _this2.state.isDraggingWithTouch && !_this2.props.disabled) {\n      // the requestAnimationFrame function must be executed in the context of window\n      // see http://stackoverflow.com/a/9678166/837709\n      var animationFrame = _animationFrameManagement.requestAnimationFrame.call(window, _this2._triggerUpdateComponentOnTouchMoveAtHandle.bind(_this2, event.touches[0]));\n\n      if (_this2.previousTouchMoveAtHandleFrame) {\n        // the cancelAnimationFrame function must be executed in the context of window\n        // see http://stackoverflow.com/a/9678166/837709\n        _animationFrameManagement.cancelAnimationFrame.call(window, _this2.previousTouchMoveAtHandleFrame);\n      }\n\n      _this2.previousTouchMoveAtHandleFrame = animationFrame;\n    }\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onTouchMove) {\n      _this2.props.handleProps.onTouchMove(event);\n    }\n  };\n\n  this._onTouchEndHandle = function (event) {\n    // prevent the onClick to happen\n    event.preventDefault();\n\n    if (_this2.state.isDraggingWithTouch && !_this2.props.disabled) {\n      // no click & move was involved\n      if (_this2._touchDragEnd) {\n        if (_this2._preventTouchSwitch) {\n          var value = _this2._touchDragEnd > _this2._getHandleWidth() / 2;\n\n          _this2._triggerChange(value);\n        } else {\n          _this2._triggerChange(!_this2.state.value);\n        }\n      } else {\n        // click like\n        _this2._triggerChange(!_this2.state.value);\n      }\n    } else {\n      _this2.setState({\n        isActive: false,\n        isDraggingWithTouch: false\n      });\n    }\n\n    _this2._touchDragStart = undefined;\n    _this2._touchDragEnd = undefined;\n    _this2._preventTouchSwitch = false;\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onTouchEnd) {\n      _this2.props.handleProps.onTouchEnd(event);\n    }\n  };\n\n  this._onTouchCancelHandle = function (event) {\n    _this2.setState({\n      isDraggingWithTouch: false\n    });\n\n    _this2._touchDragStart = undefined;\n    _this2._touchDragEnd = undefined;\n    _this2._preventTouchSwitch = false;\n\n    if (_this2.props.handleProps && _this2.props.handleProps.onTouchCancel) {\n      _this2.props.handleProps.onTouchCancel(event);\n    }\n  };\n\n  this._onKeyDown = function (event) {\n    if (!_this2.props.disabled) {\n      if (event.key === 'ArrowLeft') {\n        event.preventDefault();\n\n        _this2._onArrowLeftKeyDown();\n      } else if (event.key === 'ArrowRight') {\n        event.preventDefault();\n\n        _this2._onArrowRightKeyDown();\n      } else if (event.key === 'Enter' || event.key === ' ') {\n        event.preventDefault();\n\n        _this2._onEnterOrSpaceKeyDown();\n      }\n    }\n\n    if (_this2.props.onKeyDown) {\n      _this2.props.onKeyDown(event);\n    }\n  };\n\n  this._onMouseEnterAtSliderWrapper = function () {\n    _this2.setState({\n      isHovered: true\n    });\n\n    if (_this2.props.onMouseEnter) {\n      _this2.props.onMouseEnter(event);\n    }\n  };\n\n  this._onMouseLeaveAtSliderWrapper = function () {\n    _this2.setState({\n      isHovered: false,\n      isActive: false\n    });\n\n    if (_this2.props.onMouseLeave) {\n      _this2.props.onMouseLeave(event);\n    }\n  };\n};\n\nexports.default = Toggle;","map":null,"metadata":{},"sourceType":"script"}