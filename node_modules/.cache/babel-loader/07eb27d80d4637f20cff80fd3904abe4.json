{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _injectStyle = require('../utils/inject-style');\n\nvar _unionClassNames = require('../utils/union-class-names');\n\nvar _unionClassNames2 = _interopRequireDefault(_unionClassNames);\n\nvar _helpers = require('../utils/helpers');\n\nvar _comboBox = require('../style/combo-box');\n\nvar _comboBox2 = _interopRequireDefault(_comboBox);\n\nvar _ComboBoxItem = require('../components/ComboBoxItem');\n\nvar _ComboBoxItem2 = _interopRequireDefault(_ComboBoxItem);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar comboBoxPropTypes = {\n  children: _propTypes2.default.oneOfType([_propTypes2.default.array, _propTypes2.default.object]),\n  defaultValue: _propTypes2.default.string,\n  value: _propTypes2.default.string,\n  valueLink: _propTypes2.default.shape({\n    value: _propTypes2.default.string,\n    requestChange: _propTypes2.default.func.isRequired\n  }),\n  placeholder: _propTypes2.default.string,\n  disabled: _propTypes2.default.bool,\n  wrapperProps: _propTypes2.default.object,\n  menuProps: _propTypes2.default.object,\n  caretProps: _propTypes2.default.object,\n  onUpdate: _propTypes2.default.func,\n  onInputMatch: _propTypes2.default.func,\n  tabIndex: _propTypes2.default.number,\n  onKeyDown: _propTypes2.default.func,\n  onFocus: _propTypes2.default.func,\n  onBlur: _propTypes2.default.func,\n  className: _propTypes2.default.string,\n  caretClassName: _propTypes2.default.string,\n  style: _propTypes2.default.object,\n  wrapperStyle: _propTypes2.default.object,\n  hintStyle: _propTypes2.default.object,\n  menuStyle: _propTypes2.default.object,\n  focusStyle: _propTypes2.default.object,\n  disabledStyle: _propTypes2.default.object,\n  disabledHoverStyle: _propTypes2.default.object,\n  hoverStyle: _propTypes2.default.object,\n  caretToOpenStyle: _propTypes2.default.object,\n  caretToCloseStyle: _propTypes2.default.object,\n  disabledCaretToOpenStyle: _propTypes2.default.object,\n  maxOptions: _propTypes2.default.number,\n  displayCaret: _propTypes2.default.bool,\n  enableHint: _propTypes2.default.bool,\n  filterFunc: _propTypes2.default.func,\n  'aria-label': _propTypes2.default.string\n};\n/**\n * Update hover style for the specified styleId.\n *\n * @param styleId {string} - a unique id that exists as class attribute in the DOM\n * @param caretStyleId {string} - unique is assigned as class to caret span\n * @param properties {object} - the components properties optionally containing hoverStyle\n */\n\nfunction updatePseudoClassStyle(styleId, caretStyleId, properties) {\n  var hoverStyle = _extends({}, _comboBox2.default.hoverStyle, properties.hoverStyle);\n\n  var focusStyle = _extends({}, _comboBox2.default.focusStyle, properties.focusStyle);\n\n  var disabledHoverStyle = _extends({}, _comboBox2.default.disabledHoverStyle, properties.disabledHoverStyle);\n\n  var caretFocusStyle = _extends({}, _comboBox2.default.caretFocusStyle);\n\n  var styles = [{\n    id: styleId,\n    style: hoverStyle,\n    pseudoClass: 'hover'\n  }, {\n    id: styleId,\n    style: disabledHoverStyle,\n    pseudoClass: 'hover',\n    disabled: true\n  }, {\n    id: styleId,\n    style: focusStyle,\n    pseudoClass: 'focus'\n  }, {\n    id: caretStyleId,\n    style: caretFocusStyle,\n    pseudoClass: 'focus'\n  }];\n  (0, _injectStyle.injectStyles)(styles);\n}\n/**\n * Returns an object with properties that are relevant for the wrapper div.\n */\n\n\nfunction sanitizeWrapperProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'aria-label', 'aria-disabled']);\n}\n/**\n * Returns an object with properties that are relevant for the input box.\n */\n\n\nfunction sanitizeInputProps(properties) {\n  return (0, _helpers.omit)(properties, Object.keys(comboBoxPropTypes));\n}\n/**\n * Returns an object with properties that are relevant for the wrapping div of\n * the selected option.\n */\n\n\nfunction sanitizeCaretProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'className', 'onClick', 'tabIndex']);\n}\n/**\n * Returns an object with properties that are relevant for the combo-box menu.\n */\n\n\nfunction sanitizeMenuProps(properties) {\n  return (0, _helpers.omit)(properties, ['style', 'ref', 'role']);\n}\n/**\n * Default function used for filtering options.\n */\n\n\nfunction filterFunc(inputValue, optionValue) {\n  if (inputValue && optionValue) {\n    return optionValue.toLowerCase().indexOf(inputValue.toLowerCase()) > -1;\n  }\n\n  return false;\n}\n/**\n * ComboBox React Component.\n */\n\n\nvar ComboBox = function (_Component) {\n  _inherits(ComboBox, _Component);\n\n  function ComboBox(properties) {\n    _classCallCheck(this, ComboBox);\n\n    var _this = _possibleConstructorReturn(this, (ComboBox.__proto__ || Object.getPrototypeOf(ComboBox)).call(this, properties));\n\n    _this._onTouchStartAtOption = function (event, index) {\n      if (!_this.props.disabled && event.touches.length === 1) {\n        _this._touchStartedAt = index;\n\n        _this.setState({\n          focusedOptionIndex: index\n        });\n      }\n    };\n\n    _this._onTouchEndAtOption = function (event, index) {\n      if (!_this.props.disabled && _this._touchStartedAt) {\n        if (_this._touchStartedAt === index) {\n          event.preventDefault();\n\n          _this._triggerChange(_this._getValueForIndex(index));\n        }\n\n        _this._touchStartedAt = undefined;\n      }\n    };\n\n    _this._onTouchCancelAtOption = function () {\n      if (!_this.props.disabled) {\n        _this._touchStartedAt = undefined;\n\n        _this.setState({\n          focusedOptionIndex: undefined\n        });\n      }\n    };\n\n    _this._onBlur = function (event) {\n      if (!_this.props.disabled) {\n        _this.setState({\n          isOpen: false,\n          focusedOptionIndex: undefined\n        });\n      }\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(event);\n      }\n    };\n\n    _this._onFocus = function (event) {\n      if (!_this.props.disabled) {\n        _this.setState({\n          isOpen: true\n        });\n      }\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(event);\n      }\n    };\n\n    _this._onCaretClick = function () {\n      if (!_this.props.disabled) {\n        var isOpen = !_this.state.isOpen;\n\n        _this.setState({\n          isOpen: isOpen\n        });\n      }\n    };\n\n    _this._onMouseEnterAtOption = function (index) {\n      if (!_this.props.disabled) {\n        _this.setState({\n          focusedOptionIndex: index\n        });\n      }\n    };\n\n    _this._onMouseLeaveAtOption = function () {\n      if (!_this.props.disabled) {\n        _this.setState({\n          focusedOptionIndex: undefined\n        });\n      }\n    };\n\n    _this._onClickAtOption = function (index) {\n      if (!_this.props.disabled) {\n        _this._triggerChange(_this._getValueForIndex(index));\n      }\n    };\n\n    _this._onKeyDown = function (event) {\n      if (!_this.props.disabled) {\n        if (!_this.state.isOpen) {\n          if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n            event.preventDefault();\n\n            _this.setState({\n              isOpen: true\n            });\n          }\n        } else {\n          if (event.key === 'ArrowDown') {\n            event.preventDefault();\n\n            _this._onArrowDownKeyDown();\n          } else if (event.key === 'ArrowUp') {\n            event.preventDefault();\n\n            _this._onArrowUpKeyDown();\n          } else if (event.key === 'ArrowRight') {\n            if (_this.props.enableHint) {\n              event.preventDefault();\n\n              var hint = _this._getHint();\n\n              if (hint) {\n                _this._userUpdateValue(hint);\n              }\n            }\n          } else if (event.key === 'Enter') {\n            event.preventDefault();\n\n            _this._onEnterOrTabKeyDown();\n          } else if (event.key === 'Tab') {\n            // event.preventDefault(); should not be called here else tab\n            // will not be able to take user to next component on the page\n            _this._onEnterOrTabKeyDown();\n          } else if (event.key === 'Escape') {\n            event.preventDefault();\n\n            _this.setState({\n              isOpen: false,\n              focusedOptionIndex: undefined\n            });\n          }\n        }\n      }\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(event);\n      }\n    };\n\n    _this._onArrowDownKeyDown = function () {\n      var index = 0;\n\n      if (_this.state.focusedOptionIndex !== undefined && _this.state.focusedOptionIndex + 1 < _this.filteredOptions.length) {\n        index = _this.state.focusedOptionIndex + 1;\n      }\n\n      _this.setState({\n        focusedOptionIndex: index\n      });\n    };\n\n    _this._onChange = function (event) {\n      var value = event.target.value;\n\n      _this._userUpdateValue(value);\n    };\n\n    var inputValue = void 0;\n\n    if ((0, _helpers.has)(properties, 'valueLink')) {\n      inputValue = properties.valueLink.value;\n    } else if ((0, _helpers.has)(properties, 'value')) {\n      inputValue = properties.value;\n    } else if ((0, _helpers.has)(properties, 'defaultValue')) {\n      inputValue = properties.defaultValue;\n    }\n\n    _this.state = {\n      isOpen: false,\n      focusedOptionIndex: undefined,\n      inputValue: inputValue || '',\n      wrapperProps: sanitizeWrapperProps(properties.wrapperProps),\n      inputProps: sanitizeInputProps(properties),\n      caretProps: sanitizeCaretProps(properties.caretProps),\n      menuProps: sanitizeMenuProps(properties.menuProps)\n    };\n    _this.filteredOptions = ComboBox.filterOptions(inputValue, properties);\n    return _this;\n  }\n\n  _createClass(ComboBox, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      var value = void 0;\n\n      if (typeof this.state.focusedOptionIndex !== 'undefined') {\n        value = this.filteredOptions[this.state.focusedOptionIndex].props.value;\n      }\n\n      return {\n        isDisabled: this.props.disabled,\n        isHoveredValue: value\n      };\n    }\n    /**\n     * This method will calculate the hint that should be present in comboBox at some point in time. Rules:\n     * 1. If menu is not open hint is undefined\n     * 2. If menu is open but there are no filteredOptions hint is undefined\n     * 3. If if some option is highlighted hint is equal to its value\n     * 4. If no option is highlighted but some value is present in input box hint is equal to value of first filteredOptions\n     * If user has typed some text in input box and there is a hint(according to above calculations), the starting of hint\n     * is replaced by the text input by user ( this is to make sure that case of letters in hint is same as that in input box\n     * value and overlap is perfect.)\n     * todo: simplify logic in method below\n     */\n\n  }, {\n    key: '_getHint',\n    value: function _getHint() {\n      if (this.state.isOpen) {\n        var filteredOptions = this.filteredOptions;\n\n        if (filteredOptions && filteredOptions.length > 0) {\n          var hint = void 0;\n          var focusedOptionIndex = this.state.focusedOptionIndex;\n          var inputValue = this.state.inputValue;\n\n          if (focusedOptionIndex >= 0) {\n            hint = filteredOptions[focusedOptionIndex].props.value;\n          } else if (inputValue && inputValue.length > 0) {\n            hint = filteredOptions[0].props.value;\n          }\n\n          if (hint) {\n            if (inputValue && inputValue.length > 0) {\n              var position = hint.toLowerCase().indexOf(inputValue.toLowerCase());\n\n              if (position === 0) {\n                return inputValue + hint.substr(inputValue.length, hint.length - inputValue.length);\n              } else if (position === -1) {\n                return hint;\n              }\n            } else {\n              return hint;\n            }\n          }\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Generates the style-id & inject the focus & hover style.\n     */\n\n  }, {\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      var id = (0, _helpers.uniqueId)();\n      this._styleId = 'style-id' + id;\n      this._caretStyleId = 'caretStyle-id' + id;\n      updatePseudoClassStyle(this._styleId, this._caretStyleId, this.props);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(properties) {\n      var newState = {\n        wrapperProps: sanitizeWrapperProps(properties.wrapperProps),\n        inputProps: sanitizeInputProps(properties),\n        caretProps: sanitizeCaretProps(properties.caretProps),\n        menuProps: sanitizeMenuProps(properties.menuProps)\n      };\n\n      if ((0, _helpers.has)(properties, 'valueLink')) {\n        newState.inputValue = properties.valueLink.value || '';\n      } else if ((0, _helpers.has)(properties, 'value')) {\n        newState.inputValue = properties.value || '';\n      }\n\n      if (newState.inputValue) {\n        newState.filteredOptions = ComboBox.filterOptions(newState.inputValue, properties);\n      }\n\n      this.setState(newState);\n      (0, _injectStyle.removeAllStyles)([this._styleId, this._caretStyleId]);\n      updatePseudoClassStyle(this._styleId, this._caretStyleId, properties);\n    }\n    /**\n     * Remove a component's associated styles whenever it gets removed from the DOM.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      (0, _injectStyle.removeAllStyles)([this._styleId, this._caretStyleId]);\n    }\n    /**\n     * Update focusedOptionIndex when an option is touched.\n     */\n\n    /**\n     * Triggers a change event after the user touched on an Option.\n     */\n\n    /**\n     * Update focusedOptionIndex to undefined on touch cancel.\n     */\n\n    /**\n     * Closed opened combo-box options and removed focusStyles on blur.\n     */\n\n    /**\n     * Set focused state when element is focused.\n     */\n\n    /**\n     * Open/ Close menu when create is clicked.\n     */\n\n    /**\n     * Update focusedOptionIndex for component when mouse enters an option.\n     */\n\n    /**\n     * Set focusedOptionIndex to undefined.\n     */\n\n    /**\n     * Update component value when an option is clicked.\n     */\n\n    /**\n     * Handle keyDown in input (when input is focused):\n     * 1. ComboBox is closed and ArrowDown/ ArrowUp is pressed -> open the ComboBox\n     * 2. ComboBox is opened and ArrowDown is pressed -> highlight next option\n     * 3. ComboBox is opened and ArrowUp is pressed -> highlight previous option\n     * 4. ComboBox is opened and ArrowRight is pressed -> value of hint is copied over to inputBox\n     * 5. ComboBox is opened and Enter/ Tab is pressed -> update input value to value of option\n     * 6. ComboBox is opened and Esc is pressed -> close ComboBox\n     */\n\n    /**\n     * Highlight next option when arrowDown key is pressed.\n     * Highlight first option if currently last option is focused.\n     */\n\n  }, {\n    key: '_onArrowUpKeyDown',\n\n    /**\n     * Highlight previous option when arrowUp key is pressed.\n     * Highlight last option if currently first option is focused.\n     */\n    value: function _onArrowUpKeyDown() {\n      if (this.filteredOptions.length > 0) {\n        var index = this.filteredOptions.length - 1;\n\n        if (this.state.focusedOptionIndex) {\n          index = this.state.focusedOptionIndex - 1;\n        }\n\n        this.setState({\n          focusedOptionIndex: index\n        });\n      }\n    }\n    /**\n     * Update value of Input box to the value of highlighted option.\n     */\n\n  }, {\n    key: '_onEnterOrTabKeyDown',\n    value: function _onEnterOrTabKeyDown() {\n      if (this.state.focusedOptionIndex >= 0) {\n        this._triggerChange(this.filteredOptions[this.state.focusedOptionIndex].props.value);\n      }\n    }\n    /**\n     * The function will return options (if any) who's value is same as value of the combo-box input.\n     */\n\n  }, {\n    key: '_findMatch',\n    value: function _findMatch(value) {\n      return (0, _helpers.find)(this.filteredOptions, function (entry) {\n        return entry.props.value === value;\n      });\n    }\n    /**\n     * The function is called when user selects an option. Function will do following:\n     * 1. Close the options\n     * 2. Change value of input depending on whether its has value, defaultValue or valueLink property\n     * 3. Call onUpdate props function\n     */\n\n  }, {\n    key: '_triggerChange',\n    value: function _triggerChange(value) {\n      if ((0, _helpers.has)(this.props, 'valueLink')) {\n        this.props.valueLink.requestChange(value);\n        this.setState({\n          isOpen: false,\n          focusedOptionIndex: undefined\n        });\n      } else if ((0, _helpers.has)(this.props, 'value')) {\n        this.setState({\n          isOpen: false,\n          focusedOptionIndex: undefined\n        });\n      } else {\n        this.setState({\n          inputValue: value,\n          isOpen: false,\n          focusedOptionIndex: undefined\n        });\n        this.filteredOptions = ComboBox.filterOptions(value, this.props);\n      }\n\n      var obj = {\n        value: value,\n        isOptionSelection: true,\n        isMatchingOption: true\n      };\n\n      var matchedOption = this._findMatch(value);\n\n      obj.identifier = matchedOption ? matchedOption.props.identifier : undefined;\n\n      if (this.props.onUpdate) {\n        this.props.onUpdate(obj);\n      }\n    }\n    /**\n     * The function is called when user type/ paste value in the input box.\n     */\n\n  }, {\n    key: '_getValueForIndex',\n\n    /**\n     * Returns the value of the child with a certain index.\n     */\n    value: function _getValueForIndex(index) {\n      return this.filteredOptions[index].props.value;\n    }\n    /**\n     * The function is called when user inputs a value in the input box. This can be done by:\n     * 1. typing/ pasting value into input box\n     * 2. pressing arrowRight key when there is some hint in the input box\n     *\n     * Function will do following:\n     * 1. Open the options\n     * 2. Change value of input depending on whether its has value, defaultValue or valueLink property\n     * 3. Call onUpdate props function\n     */\n\n  }, {\n    key: '_userUpdateValue',\n    value: function _userUpdateValue(value) {\n      if ((0, _helpers.has)(this.props, 'valueLink')) {\n        this.props.valueLink.requestChange(value);\n        this.setState({\n          isOpen: true,\n          focusedOptionIndex: undefined\n        });\n      } else if ((0, _helpers.has)(this.props, 'value')) {\n        this.setState({\n          isOpen: true,\n          focusedOptionIndex: undefined\n        });\n      } else {\n        this.setState({\n          inputValue: value,\n          isOpen: true,\n          focusedOptionIndex: undefined\n        });\n        this.filteredOptions = ComboBox.filterOptions(value, this.props);\n      }\n\n      var obj = {\n        value: value,\n        isOptionSelection: false,\n        isMatchingOption: false\n      };\n\n      var matchedOption = this._findMatch(value);\n\n      if (matchedOption) {\n        obj.identifier = matchedOption.props.identifier;\n        obj.isMatchingOption = true;\n      }\n\n      if (this.props.onUpdate) {\n        this.props.onUpdate(obj);\n      }\n    }\n    /**\n     * Function to filter options using input value.\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var inputStyle = _extends({}, _comboBox2.default.style, this.props.style);\n\n      var hintStyle = _extends({}, _comboBox2.default.hintStyle, this.props.hintStyle);\n\n      var wrapperStyle = _extends({}, _comboBox2.default.wrapperStyle, this.props.wrapperStyle);\n\n      var menuStyle = _extends({}, _comboBox2.default.menuStyle, this.props.menuStyle);\n\n      var hint = this.props.enableHint ? this._getHint() : undefined;\n      var placeHolder = !hint ? this.props.placeholder : undefined;\n      var inputClassName = (0, _unionClassNames2.default)(this.props.className, this._styleId);\n      var tabIndex = this.props.tabIndex ? this.props.tabIndex : '0';\n\n      if (this.props.disabled) {\n        inputStyle = _extends({}, inputStyle, _comboBox2.default.disabledStyle, this.props.disabledStyle);\n      } // todo: Currently there are no different hover styles for caret, like select they are probably not really needed.\n\n\n      var caretStyle = void 0;\n\n      if (this.props.displayCaret) {\n        if (this.props.disabled) {\n          caretStyle = _extends({}, _comboBox2.default.caretToOpenStyle, this.props.caretToOpenStyle, _comboBox2.default.disabledCaretToOpenStyle, this.props.disabledCaretToOpenStyle);\n        } else if (this.state.isOpen) {\n          caretStyle = _extends({}, _comboBox2.default.caretToCloseStyle, this.props.caretToCloseStyle);\n        } else {\n          caretStyle = _extends({}, _comboBox2.default.caretToOpenStyle, this.props.caretToOpenStyle);\n        }\n      }\n\n      var computedMenuStyle = this.state.isOpen && !this.props.disabled && this.filteredOptions && this.filteredOptions.length > 0 ? menuStyle : {\n        display: 'none'\n      }; // using value for input makes it a controlled component and it will be changed in controlled manner if (1) user enters value, (2) user selects some option\n      // value will be updated depending on whether user has passed value / valueLink / defaultValue as property\n\n      return _react2.default.createElement('div', _extends({\n        style: wrapperStyle,\n        'aria-label': this.props['aria-label'],\n        'aria-disabled': this.props.disabled\n      }, this.state.wrapperProps), _react2.default.createElement('input', {\n        style: hintStyle,\n        value: hint,\n        tabIndex: -1,\n        key: 'style-hint',\n        readOnly: true\n      }), _react2.default.createElement('input', _extends({\n        disabled: this.props.disabled,\n        'aria-disabled': this.props.disabled,\n        value: this.state.inputValue,\n        placeholder: placeHolder,\n        style: inputStyle,\n        className: inputClassName,\n        onChange: this._onChange,\n        tabIndex: tabIndex,\n        onBlur: this._onBlur,\n        onFocus: this._onFocus,\n        onKeyDown: this._onKeyDown,\n        'aria-autocomplete': 'list',\n        key: 'combo-input'\n      }, this.state.inputProps)), _react2.default.createElement('span', _extends({\n        style: caretStyle,\n        className: this._caretStyleId,\n        onClick: this._onCaretClick,\n        tabIndex: -1\n      }, this.state.caretProps)), _react2.default.createElement('ul', _extends({\n        style: computedMenuStyle,\n        role: 'listbox',\n        'aria-expanded': this.state.isOpen\n      }, this.state.menuProps), _react2.default.Children.map(this.filteredOptions, function (entry, index) {\n        return _react2.default.createElement(_ComboBoxItem2.default, {\n          key: index,\n          index: index,\n          onItemTouchStart: _this2._onTouchStartAtOption,\n          onItemTouchEnd: _this2._onTouchEndAtOption,\n          onItemTouchCancel: _this2._onTouchCancelAtOption,\n          onItemClick: _this2._onClickAtOption,\n          onItemMouseEnter: _this2._onMouseEnterAtOption,\n          onItemMouseLeave: _this2._onMouseLeaveAtOption\n        }, entry);\n      })));\n    }\n  }], [{\n    key: 'filterOptions',\n    value: function filterOptions(inputValue, properties) {\n      /* eslint react/sort-comp:0*/\n      var filteredOptions = [];\n\n      if (!(0, _helpers.isEmpty)(properties.children)) {\n        if (inputValue) {\n          filteredOptions = (0, _helpers.filterReactChildren)(properties.children, function (entry) {\n            return properties.filterFunc(inputValue, entry.props.value);\n          });\n        } else {\n          filteredOptions = (0, _helpers.getArrayForReactChildren)(properties.children, function (entry) {\n            return entry;\n          });\n        }\n\n        if (properties.maxOptions) {\n          filteredOptions = filteredOptions.splice(0, properties.maxOptions);\n        }\n      }\n\n      return filteredOptions;\n    }\n  }]);\n\n  return ComboBox;\n}(_react.Component);\n\nComboBox.displayName = 'ComboBox';\nComboBox.propTypes = comboBoxPropTypes;\nComboBox.childContextTypes = {\n  isDisabled: _propTypes2.default.bool.isRequired,\n  isHoveredValue: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string, _propTypes2.default.number])\n};\nComboBox.defaultProps = {\n  disabled: false,\n  displayCaret: false,\n  enableHint: false,\n  'aria-label': 'ComboBox',\n  filterFunc: filterFunc,\n  // TODO rename to filterFunction in 4.0.0\n  tabIndex: 0,\n  children: []\n};\nexports.default = ComboBox;","map":null,"metadata":{},"sourceType":"script"}